# 150. 逆波兰表达式求值

[leecode原题](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

## 题目
根据 **逆波兰表示法**，求表达式的值。

有效的算符包括 `+、-、*、/` 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

**注意:** 两个整数之间的除法只保留整数部分。

**可以保证给定的逆波兰表达式总是有效的**。换句话说，表达式总会得出有效数值且不存在除数为 `0` 的情况。


## 示例

### 示例 1:

```text
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```

### 示例 2:

```text
输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
```

### 示例 3:

```text
输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
解释：该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```

## 提示：
- `1 <= tokens.length <= 104`
- `tokens[i]` 是一个算符`（"+"、"-"、"*"` 或 `"/"）`，或是在范围 `[-200, 200]` 内的一个整数

### 逆波兰表达式：

逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。
- 平常使用的算式则是一种中缀表达式，如 `( 1 + 2 ) * ( 3 + 4 )` 。
- 该算式的逆波兰表达式写法为 `( ( 1 2 + ) ( 3 4 + ) * )` 。

逆波兰表达式主要有以下两个优点：
- 去掉括号后表达式无歧义，上式即便写成 `1 2 + 3 4 + *` 也可以依据次序计算出正确结果。
- 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中

## 解题思路

### 思路
本题跟[1047-删除字符串中的所有相邻重复项](1047-删除字符串中的所有相邻重复项.md)整体思路是一样的，只不过把相除元素换成**栈顶两个元素相运算，并且把运算结果再次入栈**。

大体思路:
- 碰到数字，数字入栈
- 碰到运算符号的时候，取出栈顶头两个元素做运算，并将结果再次入栈。
- 最后遍历完之后，栈顶元素即是最终的运算和。

## 实现

[源码](./code/150-evaluate-reverse-polish-notation/main.go)
```go
func evalRPN(tokens []string) int {
	stack := []int{} // 用数组实现一个栈

	for _, token := range tokens {
		if token != "+" && token != "-" && token != "*" && token != "/" {
			num, _ := strconv.Atoi(token)
			stack = append(stack, num)
		} else {
			// 弹出栈头两个元素
			if len(stack) < 2 {
				return 0
			}
			firstNum := stack[len(stack)-1]
			secondNum := stack[len(stack)-2]
			stack = stack[:len(stack)-2]
			ret := 0
			switch token {
			case "+":
				ret = secondNum + firstNum
			case "-":
				ret = secondNum - firstNum
			case "*":
				ret = secondNum * firstNum
			case "/":
				ret = secondNum / firstNum
			}
			stack = append(stack, ret)
		}
	}
	return stack[0]
}
```

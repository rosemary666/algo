# 617. 合并二叉树

[leecode原题](https://leetcode.cn/problems/merge-two-binary-trees/)

## 题目

给你两棵二叉树： `root1` 和 `root2` 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

**注意: 合并过程必须从两个树的根节点开始。**

## 示例

### 示例 1:
![](images/merge.jpg)
```text
输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]
```

### 示例 2:

```text
输入：root1 = [1], root2 = [1,2]
输出：[2,2]
```

## 提示：
- 两棵树中的节点数目在范围 `[0, 2000]` 内
- `-104 <= Node.val <= 104`


## 解题思路

可以采用前序遍历实现, 同时前序遍历两棵子树, 如果都非空，则新子树根节点的值为两棵子树根节点值之和，否和只要有一边子树为空，则新子树直接为另一非空子树。

### 思路

## 实现

[源码](./code/617-merge-two-binary-trees/main.go)
```go// 递归实现
func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode {
	// 只有一边的情况下, 直接返回另一边
	if root1 == nil {
		return root2
	}
	if root2 == nil {
		return root1
	}

	root := &TreeNode{
		Left:  mergeTrees(root1.Left, root2.Left),
		Right: mergeTrees(root1.Right, root2.Right),
		Val:   root1.Val + root2.Val, // 节点值相加
	}
	return root
}
```

{"./":{"url":"./","title":"介绍","keywords":"","body":"ALGO 主要使用golang语言讲解和实现算法，包括数据结构、leetcode算法题等。 Leetcode部分主要参考了代码随想录, 然后自己做了相关的笔记和实现，便于分享和后期温习。 Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"array/":{"url":"array/","title":"数组","keywords":"","body":"数组 Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"array/704-二分查找.html":{"url":"array/704-二分查找.html","title":"704. 二分查找","keywords":"","body":"704. 二分查找 leecode原题 题目 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2: 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 解题思路 前提 数组必须是有序的，且没有重复元素(若有重复元素，返回的下标不唯一)。另外，重点注意判断的边界条件 思路 二分查找实现是比较简单的，定义三个变量left, right, mid=left+(right-left)/2。初始left=0, right=arr[len(arr)-1], 每次取arr[mid]跟目标值判断，然后判断下次查询是在mid的左边还是右边,或者找到目标值直接返回 实现 源码 func search(nums []int, target int) int { left := 0 right := len(nums) - 1 for left target { right = mid - 1 } else { return mid } } return -1 } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"array/27-移除元素.html":{"url":"array/27-移除元素.html","title":"27. 移除元素","keywords":"","body":"27. 移除元素 leecode原题 题目 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 说明： 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i 示例 示例 1: 输入：nums = [3,2,2,3], val = 3 输出：2, nums = [2,2] 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2: 输入：nums = [0,1,2,2,3,0,4,2], val = 2 输出：5, nums = [0,1,4,0,3] 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示： 0 nums.length 0 nums[i] 0 val 解题思路 思路 1. 暴力破解法(双循环) 暴力破解法很容易想到, 就是第一层循环遍历数组, 然后当找到元素跟目标值一致的时候，即开启第二个循环，将当前元素后的所有数组元素向前移动一位，同时注意，遍历数组的临时变量i和数组大小也要跟随着减小1。 显而易见: 时间复杂度：O(n^2) 空间复杂度：O(1) 2. 高效率法(单循环) 我们转变思路，定义一个目标索引值dest_index=0, 只使用一次循环, 在每次数组遍历中，判断当前遍历数组的元素值和目标值不相等的时候，我们将即arr[dest_index]=当前遍历数组的元素值, 同时dest_index++。 总体来说, 即忽略掉目标值。 显而易见: 时间复杂度：O(n) 空间复杂度：O(1) 实现 源码 1. 暴力破解法(双循环) // 暴力破解法 func removeElement1(nums []int, val int) int { size := len(nums) for i := 0; i 2. 高效率(单循环) func removeElement(nums []int, val int) int { var dest_index = 0 for i := 0; i Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"array/977-有序数组的平方.html":{"url":"array/977-有序数组的平方.html","title":"977. 有序数组的平方","keywords":"","body":"977. 有序数组的平方 leecode原题 题目 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序 示例 示例 1: 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100] 排序后，数组变为 [0,1,9,16,100] 示例 2: 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121] 提示： 1 nums.length -104 nums[i] nums 已按 非递减顺序 排序 进阶 请你设计时间复杂度为 O(n) 的算法解决本问题 解题思路 前提: 这是一个有序数组, 只是数组中的元素可能是负值 1. 暴力破解法 我们第一个想到的可能就是暴力破解法, 即第一步: 先对数组元素进行平方，第二步: 使用相关的排序方法进行排序。如果整体的时间复杂度即为(O(第一步)+0(第二步)), 如果是第二步是快排，那么整体时间复杂度即为(O(n+nlogn)). 2. 双指针法 最关键的一个点就是: 一个数组的每个元素的平方的最大值只能是在数组的两端取到，比如[-6, -3, -2, 0, 2, 5]。那么我们就转变 一个思路就是分别从数组左端和右端依次比较，寻找其中最大值。 实现方法(双指针法): 分别定义两个指针left_index=0, right_index=len(arr)-1, 以及一个变量k=len(arr)-1, 目标数组dest_arr=make([]int, len(arr)-1), 然后比较sqrt(arr[left_index])和sqrt(arr[right_index]), 然后将其中最大值插入到dest_arr[k]中，然后k-=1, 相应的left_index+=1或者right_index-=1, 直到left_index碰到rigth_index。 实现 1. 暴力破解法 算法很简单，这里就不实现了。 2. 双指针法 源码 func sortedSquares(nums []int) []int { size := len(nums) left_index := 0 right_index := size - 1 k := size - 1 dest_arr := make([]int, size) for left_index Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"array/209-长度最小的子数组.html":{"url":"array/209-长度最小的子数组.html","title":"209. 长度最小的子数组","keywords":"","body":"209. 长度最小的子数组 leecode原题 题目 给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 示例 示例 1: 输入：target = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2: 输入：target = 4, nums = [1,4,4] 输出：1 示例 3: 输入：target = 11, nums = [1,1,1,1,1,1,1,1] 输出：0 提示： 1 target 1 nums.length 1 nums[i] 进阶： 如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(nlog(n)) 时间复杂度的解法。 解题思路 思路 1. 暴力破解法 这是我们很容易想到的一种解法, 即写两层for循环, 第一层循环是代表子序列开始位置(for i:=0; i 2. 滑动窗口法 所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。 如何只使用一个for循环就完成？ 比如数组[2, 3, 1, 2, 4, 3], 我们以窗口尾索引进行第一层for循环遍历, 然后判断该窗口内的总和值是否>=目标值, 不是的话，那么窗口尾索引需要继续向前移动；是的话，我们就需要动态调整该窗口, 将窗口起始索引向前移动一位，然后继续判断，重复该过程。 实现 滑动窗口法 源码 func minSubArrayLen(target int, nums []int) int { var ( size = len(nums) window_sum = 0 //窗口值的综合 min_window_length = size + 1 //最小的窗口长度, 初始化可以初始化为数组长度+1 window_start_index = 0 // 窗口开始索引 window_end_index = 0 // 窗口结束索引 found = false ) for window_end_index = 0; window_end_index = target { found = true window_length := window_end_index - window_start_index + 1 if window_length Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"array/59-螺旋矩阵.html":{"url":"array/59-螺旋矩阵.html","title":"59. 螺旋矩阵 II","keywords":"","body":"59. 螺旋矩阵 II leecode原题 题目 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 示例 示例 1: 输入：n = 3 输出：[[1,2,3],[8,9,4],[7,6,5]] 示例 2: 输入：n = 1 输出：[[1]] 提示： 1 n 解题思路 思路 这个题直观上来看, 我们顺时针一圈(即从左到右、从上到下、从右到左、从下到上)即产生了一个顺时的矩阵外圈，然后该矩阵外圈的下一内圈也是按照同样的顺序即可产生。我们重点要注意的是: 比如从左到右完成，需要将上加一，这样从上到下的时候，不会重复产生那个顶点元素，其他方向规律是一样的。 实现 源码 func generateMatrix(n int) [][]int { var ( spiral_matrix = make([][]int, n) //螺旋矩阵 spiral_matrix_elements_sum = n * n // 螺旋矩阵元素总数 left = 0 // 左边起始位置 right = n - 1 // 右边起始位置 top = 0 // 上边起始位置 bottom = n - 1 //下边起始位置 current_num = 1 // 螺旋矩阵当前记录的元素(初始从1开始) ) for i := 0; i = left; i-- { spiral_matrix[bottom][i] = current_num current_num++ } bottom-- // 从下到上 for i := bottom; i >= top; i-- { spiral_matrix[i][left] = current_num current_num++ } left++ } return spiral_matrix } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"linked-list/":{"url":"linked-list/","title":"链表","keywords":"","body":"链表 Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"linked-list/203-移除链表元素.html":{"url":"linked-list/203-移除链表元素.html","title":"203. 移除链表元素","keywords":"","body":"203. 移除链表元素 leecode原题 题目 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。 示例 示例 1: 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5] 示例 2: 输入：head = [], val = 1 输出：[] 示例 3: 输入：head = [7,7,7,7], val = 7 输出：[] 提示： 列表中的节点数目在范围 [0, 104] 内 1 Node.val 0 val 解题思路 思路 这个题本身就是考察对链表进行删除的脚本操作, 唯一的一个关注点就是，因为考虑到比如值刚好等于头节点本身这种情况，正常我们可能需要去判断相关的情况做处理，但是我们增加一个在头结点之前增加一个虚拟头结点，这样头结点就跟其它节点处理是一样的了，最后返回的时候，我们返回虚拟头结点的next节点即可。 实现 源码 func removeElements(head *ListNode, val int) *ListNode { virtualHead := &ListNode{} virtualHead.Next = head cur_node := virtualHead for cur_node != nil && cur_node.Next != nil { if cur_node.Next.Val == val { cur_node.Next = cur_node.Next.Next } else { cur_node = cur_node.Next } } return virtualHead.Next } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"linked-list/707-设计链表.html":{"url":"linked-list/707-设计链表.html","title":"707. 设计链表","keywords":"","body":"707. 设计链表 leecode原题 题目 设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。 在链表类中实现这些功能： get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。 deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 说明： 示例 示例 1: MyLinkedList linkedList = new MyLinkedList(); linkedList.addAtHead(1); linkedList.addAtTail(3); linkedList.addAtIndex(1,2); //链表变为1-> 2-> 3 linkedList.get(1); //返回2 linkedList.deleteAtIndex(1); //现在链表是1-> 3 linkedList.get(1); //返回3 提示： 所有val值都在 [1, 1000] 之内。 操作次数将在 [1, 1000] 之内。 请不要使用内置的 LinkedList 库。 解题思路 思路 该考察点其实就是链表的基本操作，涉及到链表的增删改查操作，对于我们练习链表是一个很好的练习题。值得注意的是, 练习的时候，我们采用了增加一个链表虚拟头结点的方式, 有助于我们统一相关的链表操作方式. 实现 这里我们采用单链表实现。 源码 type Node struct { Val int Next *Node } type MyLinkedList struct { VirtualHead *Node // 虚拟头节点 } func Constructor() MyLinkedList { node := &Node{} node.Next = nil return MyLinkedList{VirtualHead: node} } // 获取链表中第 index 个节点的值。如果索引无效，则返回-1。 func (this *MyLinkedList) Get(index int) int { count := 0 ret := -1 cur_node := this.VirtualHead.Next for index >= 0 && cur_node != nil { if index == count { ret = cur_node.Val break } count++ cur_node = cur_node.Next } return ret } // 在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 func (this *MyLinkedList) AddAtHead(val int) { cur_head := this.VirtualHead.Next // 真实头结点为空 if cur_head == nil { this.VirtualHead.Next = &Node{Val: val} } else { // 真实头结点非空 insertNode := &Node{Val: val} insertNode.Next = cur_head this.VirtualHead.Next = insertNode } return } // 将值为 val 的节点追加到链表的最后一个元素。 func (this *MyLinkedList) AddAtTail(val int) { cur_node := this.VirtualHead.Next pre_node := this.VirtualHead for cur_node != nil { pre_node = cur_node cur_node = cur_node.Next } pre_node.Next = &Node{Val: val} } // 在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。 func (this *MyLinkedList) AddAtIndex(index int, val int) { if index = 0 && cur_node != nil { if index == count { insertNode := &Node{Val: val} insertNode.Next = cur_node pre_node.Next = insertNode } count++ pre_node = cur_node cur_node = cur_node.Next } if index == count { this.AddAtTail(val) } } // 如果索引 index 有效，则删除链表中的第 index 个节点。 func (this *MyLinkedList) DeleteAtIndex(index int) { count := 0 cur_node := this.VirtualHead.Next pre_node := this.VirtualHead for index >= 0 && cur_node != nil { if index == count { pre_node.Next = cur_node.Next break } count++ pre_node = cur_node cur_node = cur_node.Next } return } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"linked-list/206-反转链表.html":{"url":"linked-list/206-反转链表.html","title":"206. 反转链表","keywords":"","body":"206. 反转链表 leecode原题 题目 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例 示例 1: 输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] 示例 2: 输入：head = [1,2] 输出：[2,1] 示例 3: 输入：head = [] 输出：[] 提示： 链表中节点的数目范围是 [0, 5000] -5000 Node.val 进阶 链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？ 解题思路 思路 我们可能第一时间想到的解决思路是再使用一个新的链表，然后遍历原链表，然后在新链表中每次插入链表头即完成了反转， 但是这必然会造成空间的浪费，所以我们要考虑的还是去做到原地反转。 仔细想一想, 其实遍历的时候，只需要把下个节点的next反向指向前一个节点，依次这样完成即可。不过，需要注意的是: 遍历后头结点将变成尾结点，所以必须从头结点开始，且头结点的next指向nil. 实现 源码 迭代法 func reverseList(head *ListNode) *ListNode { // 重点是: cur_node初始化是从头结点, 然后pre_node是空指针 cur_node := head var pre_node *ListNode for cur_node != nil { next_node := cur_node.Next cur_node.Next = pre_node pre_node = cur_node cur_node = next_node } return pre_node } 递归法 func reverseList1(head *ListNode) *ListNode { return reverse_dg(nil, head) } func reverse_dg(pre *ListNode, cur *ListNode) *ListNode { if cur == nil { return pre } next := cur.Next cur.Next = pre return reverse_dg(cur, next) } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"linked-list/24-两两交换链表中的节点.html":{"url":"linked-list/24-两两交换链表中的节点.html","title":"24. 两两交换链表中的节点","keywords":"","body":"24. 两两交换链表中的节点 leecode原题 题目 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 示例 示例 1: 输入：head = [1,2,3,4] 输出：[2,1,4,3] 示例 2: 输入：head = [] 输出：[] 示例 3: 输入：head = [1] 输出：[1] 提示 链表中节点的数目在范围 [0, 100] 内 0 Node.val 解题思路 思路 首先，我们定义一个虚拟节点vitualHead, 并且该虚拟节点指向真正的头节点, 并且定义当前节点cur指向虚拟节点。那么我们需要替换1和2这两个节点本身的话, 需要有以下三个步骤: temp=cur.next // 先备份1这个节点, 下面步骤会指向变更, 先要备份temp1=cur.next.next.next //先备份3这个节点, 下面步骤会指向变更, 先要备份 cur.next = cur.next.next // 步骤一: 即将cur指向节点2 cur.next.next = temp // 步骤二: 即将节点2指向节点1(因为步骤1已经将cur.next指向变更了，所以这也是为啥要先备份节点1) temp.next = temp1 // 步骤三: 即将节点1指向节点3(因为步骤2已经将cur.next.next指向变更了，所以这也是为啥要先备份节点3) cur = cur.next.next // cur本身向前移动两位, 即cur操作完成之后，cur指向了1, 然后反复重复这个过程。 另外一个很关键的点就是，我们需要判断什么时候终止, 那么可以考虑节点数为奇数和偶数两种情况: cur.next==nil即代表为偶数(包括0)的情况，已经遍历完成 cur.next.next==nil, 即代表为奇数(包括1)的情况下，这个时候，最后一个单节点也不需要变换，也遍历完成 所以，我们整体可以判断为for(cur.next!=nil && cur.next.next!=nil) 实现 源码 type ListNode struct { Val int Next *ListNode } func swapPairs(head *ListNode) *ListNode { var vitualHead = &ListNode{} //定义一个虚拟节点 vitualHead.Next = head cur_node := vitualHead for cur_node.Next != nil && cur_node.Next.Next != nil { //终止条件很关键，以奇数个和偶数个作为判断条件, 且cur_node.Next需要写在第一位, 防止cur_node.Next.Next可能越界 temp := cur_node.Next temp1 := cur_node.Next.Next.Next cur_node.Next = cur_node.Next.Next // 第一步 cur_node.Next.Next = temp // 第二步 temp.Next = temp1 // 第三步 cur_node = cur_node.Next.Next // cur_node向前移动两位 } return vitualHead.Next } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"linked-list/19-删除链表的倒数第%20N%20个结点.html":{"url":"linked-list/19-删除链表的倒数第%20N%20个结点.html","title":"19. 删除链表的倒数第 N 个结点","keywords":"","body":"19. 删除链表的倒数第 N 个结点 Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:52:03 "},"linked-list/面试题-0207-链表相交.html":{"url":"linked-list/面试题-0207-链表相交.html","title":"面试题 02.07. 链表相交","keywords":"","body":"面试题 02.07. 链表相交 leecode原题 题目 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 图示两个链表在节点 c1 开始相交： 题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 示例 示例 1: 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Intersected at '8' 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2: 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Intersected at '2' 解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3: 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出：null 解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。 由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 这两个链表不相交，因此返回 null 。 提示： listA 中节点数目为 m listB 中节点数目为 n 0 , n 1 0 0 如果 listA 和 listB 没有交点，intersectVal 为 0 如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1] 进阶 你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？ 解题思路 思路 思路讲解直接引用的代码随想录的思路讲解部分代码随想录 简单来说，就是求两个链表交点节点的指针。 这里同学们要注意，交点不是数值相等，而是指针相等。 为了方便举例，假设节点元素数值相等，则节点指针相等。 看如下两个链表，目前curA指向链表A的头结点，curB指向链表B的头结点： 我们求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB 末尾对齐的位置，如图： 此时我们就可以比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。 否则循环退出返回空指针。 实现 源码 type ListNode struct { Val int Next *ListNode } func getIntersectionNode(headA, headB *ListNode) *ListNode { // 先算出headA, headB的长度 var ( headALen = 0 headBLen = 0 curHeadA = headA curHeadB = headB ) for curHeadA != nil { headALen += 1 curHeadA = curHeadA.Next } for curHeadB != nil { headBLen += 1 curHeadB = curHeadB.Next } // 计算headA和headB的长度差 gap := 0 var longHead, shortHead *ListNode if headALen > headBLen { gap = headALen - headBLen longHead = headA shortHead = headB } else { gap = headBLen - headALen longHead = headB shortHead = headA } // 长的链表向前移动gap位 for gap > 0 { longHead = longHead.Next gap-- } // 链表长度相等, 开始比较值 for longHead != nil { if longHead == shortHead { return longHead } longHead = longHead.Next shortHead = shortHead.Next } return nil } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"linked-list/142-环形链表II.html":{"url":"linked-list/142-环形链表II.html","title":"142. 环形链表 II","keywords":"","body":"142. 环形链表 II leecode原题 题目 给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置 （索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 不允许修改 链表。 示例 示例 1: 输入：head = [3,2,0,-4], pos = 1 输出：返回索引为 1 的链表节点 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2: 输入：head = [1,2], pos = 0 输出：返回索引为 0 的链表节点 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3: 输入：head = [1], pos = -1 输出：返回 null 解释：链表中没有环。 提示： 链表中节点的数目范围在范围 [0, 104] 内 -105 pos 的值为 -1 或者链表中的一个有效索引 解题思路 思路 详细讲解可以参考代码随想录 总体来说，关键点: 1. 判断链表是否有环 可以使用快慢指针法，分别定义 fast 和 slow指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow 指针在途中相遇 ，说明这个链表有环。 2. 找到环的入口 从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。 实现 源码 type ListNode struct { Val int Next *ListNode } func detectCycle(head *ListNode) *ListNode { // 定义一快一慢两个指针 var ( fast = head slow = head ) // 找环 // 快指针每次移动两位, 慢指针每次移动一位 for fast != nil && fast.Next != nil { fast = fast.Next.Next slow = slow.Next // fast和slow相遇, 证明有环 if fast == slow { // 寻找环的位置, 头节点和slow节点每次都向前移动一位，直到相遇，即该位置就是环所在的位置 for slow != head { slow = slow.Next head = head.Next } return head } } return nil } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"hash/":{"url":"hash/","title":"哈希表","keywords":"","body":"哈希表 Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"hash/242-有效的字母异位词.html":{"url":"hash/242-有效的字母异位词.html","title":"242. 有效的字母异位词","keywords":"","body":"242. 有效的字母异位词 leecode原题 题目 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 注意： 若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。 示例 示例 1: 输入: s = \"anagram\", t = \"nagaram\" 输出: true 示例 2: 输入: s = \"rat\", t = \"car\" 输出: false 提示： 1 , t.length s 和 t 仅包含小写字母 进阶 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 解题思路 思路 数组其实就是一个简单哈希表，而且这道题目中字符串只有小写字符，那么就可以定义一个数组，来记录字符串s里字符出现的次数。 因为字符 a 到字符 z 的ASCII也是 26 个连续的数值。 定义一个数组(大小26即可)叫做 record 用来上记录字符串s里字符出现的次数。 需要把字符映射到数组也就是哈希表的索引下标上，因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。 再遍历 字符串s的时候，只需要将 s[i] - ‘a’ 所在的元素做 +1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。 这样就将字符串s中字符出现的次数，统计出来了。 那看一下如何检查字符串t中是否出现了这些字符，同样在遍历字符串t的时候，对t中出现的字符映射哈希表索引上的数值再做-1的操作。 那么最后检查一下，record数组如果有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符，return false。 实现 源码 func isAnagram(s string, t string) bool { var arr [26]int //遍历s, 找到字符对应的相应索引, 并对该索引相对的值加1 for _, v := range s { arr[rune(v)-rune('a')] += 1 } //遍历t, 找到字符对应的相应索引, 并对该索引相对的值减1 for _, v := range t { arr[rune(v)-rune('a')] -= 1 } //遍历数组, 如果存在值为非0的, 即代表不是异构 //两个数组类型相同（包括数组的长度，数组中元素的类型）的情况下，我们可以直接通过较运算符（==和!=）来判断两个数组是否相等 return arr == [26]int{} } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"hash/349-两个数组的交集.html":{"url":"hash/349-两个数组的交集.html","title":"349. 两个数组的交集","keywords":"","body":"349. 两个数组的交集 leecode原题 题目 给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。 示例 示例 1: 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2] 示例 2: 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[9,4] 解释：[4,9] 也是可通过的 提示： 1 0 解题思路 如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费 本题虽然还是限制了数组值的范围, 但是我们还是采用其它的思路方法来解决。 思路 我们直接使用golang自带的map，按下述步骤操作: 遍历数组1，将元素作为key值存入map中 遍历数组2，判断元素是否存在map中，存在则是相同元素，并且在map中将该元素对应的key删除(因为最终重复元素只返回一个) 实现 源码 func intersection(nums1 []int, nums2 []int) []int { set := make(map[int]struct{}) arr := make([]int, 0) // 数组num1塞入set之中 for _, v := range nums1 { set[v] = struct{}{} } //遍历数组num2, 找到相同元素 for _, v := range nums2 { if _, ok := set[v]; ok { arr = append(arr, v) delete(set, v) } } return arr } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"hash/202-快乐数.html":{"url":"hash/202-快乐数.html","title":"202. 快乐数","keywords":"","body":"202. 快乐数 leecode原题 题目 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」 定义为： 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果这个过程 结果为 1，那么这个数就是快乐数。 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。 示例 示例 1: 输入：n = 19 输出：true 解释： 1^2 + 9^2 = 82 8^2 + 2^2 = 68 6^2 + 8^2 = 100 1^2 + 0^2 + 0^2 = 1 示例 2: 输入：n = 2 输出：false 提示： 1 解题思路 思路 这道题，审题很重要，从题目信息中可以知道，如果非快乐数，那么会出现无限循环， 即出现过的结果还会再次出现，所以对判断元素是否存在，我们可以使用哈希表来判断。 注意: 求取一个给定的数值(n)的各位(个位、十位...)的值(b)的方法为: for n> 0{b:=n%10;n=n/10} 实现 源码 func isHappy(n int) bool { set := make(map[int]struct{}) for n != 1 { n = calc_n2(n) _, ok := set[n] if ok { return false } set[n] = struct{}{} } return true } // 计算n各个位的平方 func calc_n2(n int) int { sum := 0 for n > 0 { sum += (n % 10) * (n % 10) n = n / 10 } return sum } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"hash/1-两数之和.html":{"url":"hash/1-两数之和.html","title":"1. 两数之和","keywords":"","body":"1. 两数之和 leecode原题 题目 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 示例 1: 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2: 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3: 输入：nums = [3,3], target = 6 输出：[0,1] 提示： 2 -109 -109 只会存在一个有效答案 进阶: 你可以想出一个时间复杂度小于 O(n2) 的算法吗？ 解题思路 leecode第一道题, 梦开始的地方...... 思路 这道题我们第一想到的可能就是一个暴力求解, 两层for循环，但是这样的话，本身时间复杂度就会达到O(n2). 我们如何能设计一个O(n)的算法呢? 借助哈希表(m), key为数组元素值，value为元素在数组中的索引. 只需遍历一遍数组，对每个数组元素v， 判断m[target-v]是否存在，存在则进行两个的索引返回，不存在则将v插入m中， 实现 源码 func twoSum(nums []int, target int) []int { res := []int{} m := make(map[int]int) for index, v := range nums { preIndex, ok := m[target-v] if ok { res = append(res, preIndex, index) break } m[v] = index } return res } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"hash/454-四数相加II.html":{"url":"hash/454-四数相加II.html","title":"454. 四数相加 II","keywords":"","body":"454. 四数相加 II leecode原题 题目 给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足： 0 nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 示例 示例 1: 输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2] 输出：2 解释： 两个元组如下： 1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0 示例 2: 输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0] 输出：1 提示： n == nums1.length n == nums2.length n == nums3.length n == nums4.length 1 -228 解题思路 思路 而这道题目是四个独立的数组，只要找到A[i] + B[j] + C[k] + D[l] = 0就可以，不用考虑有重复的四个元素相加等于0的情况. 本题解题步骤： 首先定义 一个map放a和b两数之和，value 放a和b两数之和出现的次数。 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。 定义int变量count，用来统计 a+b+c+d = 0 出现的次数。 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。 最后返回统计值 count 就可以了 实现 源码 func fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int { m := map[int]int{} // 遍历num1和num2, 统计两个数组元素之和，和出现的次数, 并且存入map之中 for _, v1 := range nums1 { for _, v2 := range nums2 { m[v1+v2]++ } } count := 0 // 遍历num3和num4，找到如果 `0-(v1+v2)` 在`map`中出现过的话，就用`count`把`map`中`key`对应的`value`也就是出现次数统计出来。 for _, v3 := range nums3 { for _, v4 := range nums4 { if times, ok := m[0-(v3+v4)]; ok { count += times } } } return count } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"hash/383-赎金信.html":{"url":"hash/383-赎金信.html","title":"383. 赎金信","keywords":"","body":"383. 赎金信 leecode原题 题目 给你两个字符串：赎金信ransomNote 和 杂志magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。 如果可以，返回 true ；否则返回 false 。 magazine 中的每个字符只能在 ransomNote 中使用一次。 示例 示例 1: 输入：ransomNote = \"a\", magazine = \"b\" 输出：false 示例 2: 输入：ransomNote = \"aa\", magazine = \"ab\" 输出：false 示例 3: 输入：ransomNote = \"aa\", magazine = \"aab\" 输出：true 提示： 1 ransomNote 和 magazine 由小写英文字母组成 解题思路 参考 这道题目和 242.有效的字母异位词 很像，这道题目是求 字符串a能否组成字符串b，而不用管字符串b 能不能组成字符串a。 本题判断第一个字符串ransomNote能不能由第二个字符串magazine里面的字符构成，但是这里需要注意两点。 第一点: 杂志里面的字母不可重复使用。 第二点: 只有小写字母，这一点很重要. 思路 因为题目所只有小写字母，那可以采用空间换取时间的哈希策略， 用一个长度为26的数组还记录magazine里字母出现的次数。 然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。 依然是数组在哈希法中的应用。 Notice:一些同学可能想，用数组干啥，都用map完事了，其实在本题的情况下，使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。 所以数组更加简单直接有效！ 实现 源码 func canConstruct(ransomNote string, magazine string) bool { // 小写字母总共只有26位，所以定义长度为26的数组大小 arr := [26]int{} // 遍历magazine字符串, ($v-`a`)代表该字符在数组的索引，同时把数组下该索引对应的值加1 for _, v := range magazine { arr[v-rune('a')]++ } // 遍历ransomNote字符串，($v-`a`)代表该字符在数组的索引, 如果该值大于0，则代表可以构成，同时该数组索引对应的值减1 for _, v := range ransomNote { if arr[v-rune('a')] Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"hash/15-三数之和.html":{"url":"hash/15-三数之和.html","title":"15. 三数之和","keywords":"","body":"15. 三数之和 leecode原题 题目 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例 示例 1: 输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 示例 2: 输入：nums = [] 输出：[] 示例 3: 输入：nums = [0] 输出：[] 提示： 0 -105 解题思路 思路 这道题详细讲解，建议直接参考代码随想录 总体来说: 排序 + 双指针 nums从小到大排序，i,j,k分别代表元素a,b,c的索引 先固定i,i的范围是区间[0, len(nums)-2)，注意要对a去重，如果nums[i] == nums[i-1]将可能出现三元组重复 固定i后，取j = i+1,k =len(nums)-1，j和k在j的情况下（j>i和j已经保证j和k在移动过程中不会数组越界）作为双指针进行遍历，判断a+b+c 如果a+b+c==0,则添加三元组,然后j++、k--，并且注意对b,c去重，原因同2中的a 如果a+b+c>0,则k-- 如果a+b+c,则j++ 实现 源码 func threeSum(nums []int) [][]int { // 对数组进行从小到大的排序 sort.Ints(nums) res := make([][]int, 0) // 定义三个数begin, left, rigth(i, left, right不能相同) for i := 0; i 0 && begin == nums[i-1] { continue } left := i + 1 // 左指针指向begin前一位 right := len(nums) - 1 // 右指针指向最后一位 for left 0 { // 因为数组已经排序, 所以right应该向数值小的地方移动 right-- } else { // 因为数组已经排序, 所以left应该向数值大的地方移动 left++ } } } return res } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"hash/18-四数之和.html":{"url":"hash/18-四数之和.html","title":"18. 四数之和","keywords":"","body":"18. 四数之和 leecode原题 题目 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）： 0 a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按任意顺序返回答案 。 示例 示例 1: 输入：nums = [1,0,-1,0,-2,2], target = 0 输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]] 示例 2: 输入：nums = [2,2,2,2,2], target = 8 输出：[[2,2,2,2]] 提示： 1 -109 -109 解题思路 思路 这道题详细讲解，建议直接参考代码随想录 另外整体思路跟解法跟三数之和是类似的，只是多了一层循环。参考三数之和 实现 源码 func fourSum(nums []int, target int) [][]int { res := make([][]int, 0) if len(nums) 0 && nums[i-1] == n1 { continue } // 第二层循环 for j := i + 1; j i+1 && nums[j-1] == n2 { continue } left := j + 1 right := len(nums) - 1 // 移动left和right指针直到相遇 for left target { // 像数值小的方向移动, 即rigth指针向左移动 right-- } else if sum Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"string/":{"url":"string/","title":"字符串","keywords":"","body":"字符串 Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"string/344-反转字符串.html":{"url":"string/344-反转字符串.html","title":"344. 反转字符串","keywords":"","body":"344. 反转字符串 leecode原题 题目 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 示例 示例 1: 输入：s = [\"h\",\"e\",\"l\",\"l\",\"o\"] 输出：[\"o\",\"l\",\"l\",\"e\",\"h\"] 示例 2: 输入：s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"] 输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] 提示： 1 s[i] 都是 ASCII 码表中的可打印字符 解题思路 思路 这个题要实现O(1)的算法空间度，重点就是可以结合我们之前在链表部分使用过的双指针方法: 初始定义i:=0;j=len(s)-1 判断是否i, 是的话，则执行步骤3，4， 否的话终止。 交换i, j对应的数组的值 i++, j-- 重复2, 3, 4这个过程 实现 源码 func reverseString(s []byte) { i := 0 j := len(s) - 1 for i Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"string/541-反转字符串II.html":{"url":"string/541-反转字符串II.html","title":"541. 反转字符串 II","keywords":"","body":"541. 反转字符串 II leecode原题 题目 给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。 如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 示例 示例 1: 输入：s = \"abcdefg\", k = 2 输出：\"bacdfeg\" 示例 2: 输入：s = \"abcd\", k = 2 输出：\"bacd\" 提示： 1 s 仅由小写英文组成 1 解题思路 思路 该题是344-反转字符串升级版，只需要在其基础上按逻辑判断，然后每个部分数组进行反转即可。 实现 源码 func reverseStr(s string, k int) string { b := []byte(s) end := len(b) for start := 0; start = k { reverse_part(b, start, start+k-1) } else { //如果剩余字符少于 k 个，则将剩余字符全部反转。 reverse_part(b, start, start+sub-1) } } return string(b) } // 反转指定部分的数组元素 func reverse_part(b []byte, start, end int) { for start Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"string/151-颠倒字符串中的单词.html":{"url":"string/151-颠倒字符串中的单词.html","title":"151. 颠倒字符串中的单词","keywords":"","body":"151. 颠倒字符串中的单词 leecode原题 题目 给你一个字符串 s ，颠倒字符串中 单词 的顺序。 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。 返回单词顺序颠倒且 单词 之间用单个空格连接的结果字符串。 注意： 输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。 示例 示例 1: 输入：s = \"the sky is blue\" 输出：\"blue is sky the\" 示例 2: 输入：s = \" hello world \" 输出：\"world hello\" 解释：颠倒后的字符串中不能存在前导空格和尾随空格。 示例 3: 输入：s = \"a good example\" 输出：\"example good a\" 解释：如果两个单词间有多余的空格，颠倒后的字符串需要将单词间的空格减少到仅有一个。 提示： 1 s 包含英文大小写字母、数字和空格 ' ' s 中 至少存在一个 单词 进阶： 如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 O(1) 额外空间复杂度的 原地 解法。 解题思路 思路 我们挑战一下使用O(1)空间复杂度的解法，即只在原字符数组上进行操作. 整体思路: 移除多余空格(包括字符串开头、结尾以及字符之间多余1个空格的其他空格) 将整个字符串反转 将每个单词反转(字符串按空格切分为多个单词，单词内部再次反转) 比如说，原字符串为：\" the sky is blue \" 移除多余空格 : \"the sky is blue\" 字符串反转：\"eulb si yks eht\" 单词反转：\"blue is sky the\" 难点:如何原地进行空格移除，这里就需要借用到快慢指针的用法了。 定义快慢指针 快指针向前移动，碰到非空字符时，将快指针的值赋给慢指针(额外要注意判断是不是字符串开头以及是单词的第一个字母，是的话，需要做一个空格的补充) 实现 源码 func reverseWords(s string) string { b := []byte(s) bLen := len(b) /*---------------------1. 移除空格(开头、结尾以及单词之间多余一个的空格)----------------------*/ slowIndex := 0 // 定义慢指针 fastIndex := 0 // 定义快指针 for ; fastIndex Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"string/58-II左旋转字符串.html":{"url":"string/58-II左旋转字符串.html","title":"58 - II. 左旋转字符串","keywords":"","body":"58 - II. 左旋转字符串 leecode原题 题目 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\"abcdefg\"和数字2，该函数将返回左旋转两位得到的结果\"cdefgab\"。 示例 示例 1: 输入: s = \"abcdefg\", k = 2 输出: \"cdefgab\" 示例 2: 输入: s = \"lrloseumgh\", k = 6 输出: \"umghlrlose\" 提示： 1 解题思路 思路 本题进阶一下做法就是如何不申请额外的空间，完成左旋转. 具体做法类似:151-颠倒字符串中的单词 这道题目也非常类似，依然可以通过局部反转+整体反转 达到左旋转的目的。 具体步骤为： 反转区间为前n的子串 反转区间为n到末尾的子串 反转整个字符串 实现 源码 func reverseLeftWords(s string, n int) string { b := []byte(s) /*-------------1. 反转前n个字符----------------*/ reverseStr(b, 0, n-1) /*-------------2. 反转第n个后面的字符----------------*/ reverseStr(b, n, len(b)-1) /*-------------3. 整体字符串反转----------------*/ reverseStr(b, 0, len(b)-1) return string(b) } func reverseStr(b []byte, start, end int) { for start Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"string/28-实现strStr.html":{"url":"string/28-实现strStr.html","title":"28. 实现 strStr","keywords":"","body":"28. 实现 strStr() leecode原题 题目 实现 strStr() 函数。 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。 说明： 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。 示例 示例 1: 输入：haystack = \"hello\", needle = \"ll\" 输出：2 示例 2: 输入：haystack = \"aaaaa\", needle = \"bba\" 输出：-1 提示： 1 haystack 和 needle 仅由小写英文字符组成 解题思路 思路 这里参考小白KMP算法 讲清楚next数组生成代码, 图文讲解还是很清晰的。 KMP算法的由来和本文术语解释 KMP算法的中文名称为快速模式匹配算法，是为了快速解决在一个字符串中查找另一个字符串的问题。（为了方便描述，要找到的那个字符串叫模式串，要搜索的那个范围叫文本串。比如要求在字符串abbaf中找到字符串baf，baf就是模式串，abbaf就是文本串）。 针对这种问题，我们其实很容易想到一种暴力的算法，那就是一个一个比。 不难发现，遇到不匹配的情况时，模式串每次都是傻傻的挪一下，然后再一位一位地去比较。 暴力太傻了吧，所以就有了KMP算法，让模式串迈开腿，能够大步往前走。但大步走也不是瞎走，不然走过了相等的村就没有相等的店了，得有点策略地走，于是有了next数组。这个数组的名字起的其实还是有点形象的，代表比到某一位不匹配了下一个比哪一位，像一个指导手册似的。 为什么要有next数组以及对他的直观理解 next数组就是一个模式串的行为指导手册。 当红色的C和A不匹配时，黄色的AB和AB已经比较过了，而模式串p中橙色和黄色部分是相等的，那挺好，黄色AB都跟文本串比过了，橙色的AB就可以省点事，这样直接比较绿色箭头处就可以了。 那我们怎么决定从哪一位开始比较呢。这里就引入了前后缀的问题。要找到模式串p中不匹配位置A前面的子串\"ABCAB\"中相同的前缀和后缀，这个相同的部分就是可以偷懒不用比的部分了。那如果相同的前缀和后缀有很多取哪个呢？那肯定取最长的呀，这样就能偷更多懒，下一轮不用比的就更多了。 所以，为了知道如何偷懒，我们定义了一个没有名字的表，这个表告诉我们以某个位置的字符结尾的字符串，最长的相同前后缀的长度是多少。 看下图理解最长相同前后缀。 那为啥要知道长度呢？长度其实就是下一次的下标。以下图为例，A前面以B为结尾的字符串ABCAB的最长相同前后缀的长度为2，那下一轮比较的就是2位置的C，前面的不用比了。 那么这个时候next数组就出场了，他就和这个不知名的表有关系，但又不完全一样，但本质上next都是由这张表变来的。 实际实现时根据需要可能把这个表的所有元素-1，也可能所有元素右移之类的(右移的话AC不匹配时就不用看前一位的next了，直接看自己位置的就行，因为别人的右移到自己的地盘了)。我也不知道为啥就要-1之类的，除了让KMP更难理解以外，好像啥用没有。 本文就不进行这些花里胡哨的操作了。 精华！next数组的代码实现 图预警 到现在大部分人估计都能手写一个模式串的next的数组了，毕竟肉眼看最长的相同前后缀也还行。但是看到代码实现的时候还是会懵的不行，这是因为真的太巧妙了，其中甚至用到了递归的思路。为了好理解，我就直接将前文图中推导的表作为next数组。 递归思路如何画图理解 定义两个指针，cur是指向当前位置的，代表要求以cur位置字符结尾的最长相同前后缀，recur有两个含义，可能是上一轮循环之后传过来的（代表以前一个字符结尾的最长相同前后缀），也可能是递归的时候递归到的，反正也不用管这么多，反正recur在赋值给next时候就会指向最长相同前缀的下一位。 画图理解递归的思路 如图显示的是进入某一轮循环，cur=17,recur=8时递归代码的执行过程。 next[cur-1]= next[16] = 8代表红色的两个框相同（时刻牢记next的含义） 如果这个时候s[cur] == s[recur]说明next[cur] = recur+1=9,表示最长相同前后缀长度为9。 如果这个时候s[cur] != s[recur]说明next[cur] ,这里就要用到递归了。红色框中字符相等，我们求的最长相同后缀是以cur结尾的那一撮，那就可以转化为求recur-1结尾的最长相同前后缀,即next[recur-1]。根据next[recur-1]=next[7]的值3可以知道左边两个绿框相同，所以图中四个绿框就都相同了。但是咱要的其实还是左右边上的两个绿框相等。 接下来就还是循环第一步，recur指针移到新的红色位置。如果这时next[cur] == next[recur]的话，next[cur] = recur+1=4。如果不相等，那recur还要递归移动，直到recur = 0时不能再移动或者遇到相等的情况。 计算next时初始化值如何确定 另外，代码的初始条件也不能看着答案想当然。next[0]=0是因为只有s[0]一个元素时，不存在最长相同前后缀。j的初始化有两种办法可以考虑，一种是观察for循环中的next[i]=j，所以next[0]=0时j就是0。也可以在计算next[1]的时候看看，需要j是几才能得到正确答案。 计算结果的图形化解释 以字符串\"ABCABA\"为例运行代码，中间过程如下图。 利用next实现KMP的关键要点 有了next数组之后，如何利用他呢？大体来说是控制模式串指针和文本串指针的移动，直到到达文本串末尾或者模式串末尾。其中有以下几个要点： 遇到某一位不匹配时，要根据这一位前一位的next值确认接下来要比较的是模式串中的哪一位(也就是模式串指针指向哪里)。 1中改变了模式串指针之后，文本串指针不能移动到下一位，而是要保持不变，继续比较，否则就会越过一些值。所以for内部需要有while循环，而不能写if让其进入下一轮for循环。 实现 源码 // 获取next数组 func getNextArr(needle string) (next []int) { next = make([]int, len(needle)) cur := 0 //cur是指向当前位置的，代表要求以cur位置字符结尾的最长相同前后缀 recur := 0 //recur有两个含义，可能是上一轮循环之后传过来的（代表以前一个字符结尾的最长相同前后缀），也可能是递归的时候递归到的，反正也不用管这么多，**反正recur在赋值给next时候就会指向最长相同前缀的下一位** next[0] = 0 for cur = 1; cur 0 && needle[cur] != needle[recur] { recur = next[recur-1] } // 如果相等，代表最长公共前后缀+1 if needle[cur] == needle[recur] { recur++ } next[cur] = recur } return next } func strStr(haystack string, needle string) int { // 对于本题而言，当 `needle` 是空字符串时我们应当返回 `0` 。这与 C 语言的 `strstr()` 以及 Java 的 `indexOf()` 定义相符。 if len(needle) == 0 { return 0 } j := 0 // 指向next数组 next := getNextArr(needle) for i := 0; i 0 && haystack[i] != needle[j] { j = next[j-1] } if haystack[i] == needle[j] { j++ } if j == len(needle) { return i - j + 1 } } // 不存在返回-1 return -1 } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"string/459-重复的子字符串.html":{"url":"string/459-重复的子字符串.html","title":"459. 重复的子字符串","keywords":"","body":"459. 重复的子字符串 leecode原题 题目 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。 示例 示例 1: 输入: s = \"abab\" 输出: true 解释: 可由子串 \"ab\" 重复两次构成。 示例 2: 输入: s = \"aba\" 输出: false 示例 3: 输入: s = \"abcabcabcabc\" 输出: true 解释: 可由子串 \"abc\" 重复四次构成。 (或子串 \"abcabc\" 重复两次构成。) 提示： 1 s 由小写英文字母组成 解题思路 思路 具体的推理过程详见: 代码随想录 主要高效解决方案是采用KMP算法，思路就是: 数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。 实现 源码 // 获取next数组 func getNextArr(needle string) (next []int) { next = make([]int, len(needle)) cur := 0 //cur是指向当前位置的，代表要求以cur位置字符结尾的最长相同前后缀 recur := 0 //recur有两个含义，可能是上一轮循环之后传过来的（代表以前一个字符结尾的最长相同前后缀），也可能是递归的时候递归到的，反正也不用管这么多，**反正recur在赋值给next时候就会指向最长相同前缀的下一位** next[0] = 0 for cur = 1; cur 0 && needle[cur] != needle[recur] { recur = next[recur-1] } // 如果相等，代表最长公共前后缀+1 if needle[cur] == needle[recur] { recur++ } next[cur] = recur } return next } func repeatedSubstringPattern(s string) bool { n := len(s) if n == 0 { return false } next := getNextArr(s) // 数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。 if next[n-1] != 0 && n%(n-next[n-1]) == 0 { return true } return false } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"stacks-queues/":{"url":"stacks-queues/","title":"栈和队列","keywords":"","body":"栈和队列 Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"stacks-queues/232-用栈实现队列.html":{"url":"stacks-queues/232-用栈实现队列.html","title":"232. 用栈实现队列","keywords":"","body":"232. 用栈实现队列 leecode原题 题目 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明： 你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 示例 示例 1: 输入： [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"] [[], [1], [2], [], [], []] 输出： [null, null, null, 1, 1, false] 解释： MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false 提示： 1 最多调用 100 次 push、pop、peek 和 empty 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek操作） 进阶 你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。 解题思路 思路 该题主要考察栈和队列的基本概念和基本功能函数。用栈实现队列，这里需要两个栈才行，一个输入栈，一个输出栈。 具体思路: 在push数据的时候，只要数据放进输入栈就好，但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入），再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。 最后如何判断队列为空呢？如果进栈和出栈都为空的话，说明模拟的队列为空了。 实现 源码 type MyQueue struct { stackIn []int // 输入栈 stackOut []int // 输出栈 } func Constructor() MyQueue { return MyQueue{ stackIn: make([]int, 0), stackOut: make([]int, 0), } } // 将元素 `x` 推到队列的末尾 func (this *MyQueue) Push(x int) { // 直接像输入栈塞入数据即可 this.stackIn = append(this.stackIn, x) return } // 从队列的开头移除并返回元素 func (this *MyQueue) Pop() int { x := 0 // 如果输出栈为空, 则将输入栈的数据读取存入输出栈(导入） if len(this.stackOut) == 0 && len(this.stackIn) != 0 { for i := len(this.stackIn) - 1; i >= 0; i-- { // 输入栈入栈 this.stackOut = append(this.stackOut, this.stackIn[i]) } this.stackIn = make([]int, 0) } // 从stackOut栈顶取元素 if len(this.stackOut) > 0 { x = this.stackOut[len(this.stackOut)-1] this.stackOut = this.stackOut[:len(this.stackOut)-1] } return x } // 返回队列开头的元素 func (this *MyQueue) Peek() int { x := 0 // 如果输出栈为空, 则将输入栈的数据读取存入输出栈(导入） if len(this.stackOut) == 0 && len(this.stackIn) != 0 { for i := len(this.stackIn) - 1; i >= 0; i-- { this.stackOut = append(this.stackOut, this.stackIn[i]) } this.stackIn = make([]int, 0) } // 从stackOut栈顶取元素 if len(this.stackOut) > 0 { x = this.stackOut[len(this.stackOut)-1] } return x } // 如果队列为空，返回 `true` ；否则，返回 `false` func (this *MyQueue) Empty() bool { if len(this.stackIn) != 0 || len(this.stackOut) != 0 { return false } return true } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"stacks-queues/225-用队列实现栈.html":{"url":"stacks-queues/225-用队列实现栈.html","title":"225. 用队列实现栈","keywords":"","body":"225. 用队列实现栈 leecode原题 题目 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。 实现 MyStack 类： void push(int x) 将元素 x 压入栈顶。 int pop() 移除并返回栈顶元素。 int top() 返回栈顶元素。 boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。 注意： 你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 示例 示例 1: 输入： [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"] [[], [1], [2], [], [], []] 输出： [null, null, null, 2, 2, false] 解释： MyStack myStack = new MyStack(); myStack.push(1); myStack.push(2); myStack.top(); // 返回 2 myStack.pop(); // 返回 2 myStack.empty(); // 返回 False 提示 1 最多调用100 次 push、pop、top 和 empty 每次调用 pop 和 top 都保证栈不为空 进阶 你能否仅用一个队列来实现栈。 解题思路 思路 这里进阶一下，只采用一个队列去模拟实现栈的功能。 主要重难点就是Pop方法的实现: 每次pop的时候，将除队列尾部的那个元素全部pop出来，在重新push进入队列。 最后将队尾元素进行pop即可。 实现 源码 package main import \"fmt\" type MyStack struct { queue []int // 用数组实现一个队列的功能 } func Constructor() MyStack { return MyStack{ queue: make([]int, 0), } } // 将元素 `x` 压入栈顶。 func (this *MyStack) Push(x int) { // 直接把元素加入队列即可 this.queue = append(this.queue, x) } // 移除并返回栈顶元素 func (this *MyStack) Pop() int { if len(this.queue) == 0 { return 0 } // 弹出除队尾元素的所有元素，并重新追加到队列中 n := len(this.queue) - 1 for n != 0 { // 模拟队列头弹出元素，并且把队列头元素重新加入队列尾部 x := this.queue[0] this.queue = this.queue[1:] this.queue = append(this.queue, x) n-- } x := this.queue[0] this.queue = this.queue[1:] return x } // 返回栈顶元素 func (this *MyStack) Top() int { x := this.Pop() if x == 0 { return x } this.Push(x) return x } // 如果栈是空的，返回 `true` ；否则，返回 `false` func (this *MyStack) Empty() bool { if len(this.queue) != 0 { return false } return true } func main() { println(\"UseCase 1......\") stack := Constructor() stack.Push(1) stack.Push(2) fmt.Printf(\"Peek: %v \\n\", stack.Top()) fmt.Printf(\"Pop: %v \\n\", stack.Pop()) fmt.Printf(\"Empty: %v \\n\", stack.Empty()) } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"stacks-queues/20-有效的括号.html":{"url":"stacks-queues/20-有效的括号.html","title":"20. 有效的括号","keywords":"","body":"20. 有效的括号 leecode原题 题目 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例 示例 1: 输入：s = \"()\" 输出：true 示例 2: 输入：s = \"()[]{}\" 输出：true 示例 3: 输入：s = \"(]\" 输出：false 示例 4: 输入：s = \"([)]\" 输出：false 示例 5: 输入：s = \"{[]}\" 输出：true 提示： 1 s 仅由括号 '()[]{}' 组成 解题思路 思路 该题是一个很典型的使用栈解决问题的经典题目。 具体思路就是: 遍历字符串: 情况1: 遇到左括号，直接将左括号对应的右括号入栈 情况2: 栈非空, 且右括号和栈顶元素相等，则弹出栈顶元素 其他情况: 代表不匹配(比如遇到右括号，但是栈非空，或者右括号和栈顶元素不相同) 遍历完成之后, 栈不为空的话(比如最后都是连续的几个左括号)，则也代表不匹配。 实现 源码 func isValid(s string) bool { n := len(s) if n == 0 { return true } stack := []byte{} // 用数组实现一个栈 // 字符括号映射表 charMap := map[byte]byte{ '{': '}', '(': ')', '[': ']', } for i := 0; i 0 && s[i] == stack[len(stack)-1] { // 当前字符映射匹配到栈首元素, 栈弹出 stack = stack[:len(stack)-1] } else { return false } } // 最终判断栈是否为空 if len(stack) != 0 { return false } return true } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"stacks-queues/1047-删除字符串中的所有相邻重复项.html":{"url":"stacks-queues/1047-删除字符串中的所有相邻重复项.html","title":"1047. 删除字符串中的所有相邻重复项","keywords":"","body":"1047. 删除字符串中的所有相邻重复项 leecode原题 题目 给出由小写字母组成的字符串S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。 在 S 上反复执行重复项删除操作，直到无法继续删除。 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 示例 1: 输入：\"abbaca\" 输出：\"ca\" 解释： 例如，在 \"abbaca\" 中，我们可以删除 \"bb\" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 \"aaca\"，其中又只有 \"aa\" 可以执行重复项删除操作，所以最后的字符串为 \"ca\"。 提示： 1 S 仅由小写英文字母组成。 解题思路 思路 可以把字符串顺序放到一个栈中，遍历过程中，如果遍历到的字符和栈首元素相同的话 栈就弹出，这样最后栈里剩下的元素都是相邻不相同的元素了。 值得注意的是: 因为从栈里弹出的元素是倒序的，所以在对字符串进行反转一下，就得到了最终的结果。 实现 源码 func removeDuplicates(s string) string { n := len(s) stack := []byte{} //用数组模拟栈 for i := 0; i 0 && s[i] == stack[len(stack)-1] { stack = stack[:len(stack)-1] } else { // 直接入栈 stack = append(stack, s[i]) } } // 这里还是模拟栈实现, 就不直接用原数组了 // 将栈内剩余元素取出，并倒序排序即可。 elements := make([]byte, len(stack)) for i := len(stack) - 1; i >= 0; i-- { // 弹出栈首元素 x := stack[len(stack)-1] stack = stack[:len(stack)-1] // 栈首元素从数组最后开始往前存放 elements[i] = x } return string(elements) } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"stacks-queues/150-逆波兰表达式求值.html":{"url":"stacks-queues/150-逆波兰表达式求值.html","title":"150. 逆波兰表达式求值","keywords":"","body":"150. 逆波兰表达式求值 leecode原题 题目 根据 逆波兰表示法，求表达式的值。 有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 注意: 两个整数之间的除法只保留整数部分。 可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 示例 1: 输入：tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"] 输出：9 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 示例 2: 输入：tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"] 输出：6 解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 示例 3: 输入：tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"] 输出：22 解释：该算式转化为常见的中缀算术表达式为： ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 提示： 1 tokens[i] 是一个算符（\"+\"、\"-\"、\"*\" 或 \"/\"），或是在范围 [-200, 200] 内的一个整数 逆波兰表达式： 逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。 逆波兰表达式主要有以下两个优点： 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中 解题思路 思路 本题跟1047-删除字符串中的所有相邻重复项整体思路是一样的，只不过把相除元素换成栈顶两个元素相运算，并且把运算结果再次入栈。 大体思路: 碰到数字，数字入栈 碰到运算符号的时候，取出栈顶头两个元素做运算，并将结果再次入栈。 最后遍历完之后，栈顶元素即是最终的运算和。 实现 源码 func evalRPN(tokens []string) int { stack := []int{} // 用数组实现一个栈 for _, token := range tokens { if token != \"+\" && token != \"-\" && token != \"*\" && token != \"/\" { num, _ := strconv.Atoi(token) stack = append(stack, num) } else { // 弹出栈头两个元素 if len(stack) Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"stacks-queues/239-滑动窗口最大值.html":{"url":"stacks-queues/239-滑动窗口最大值.html","title":"239. 滑动窗口最大值","keywords":"","body":"239. 滑动窗口最大值 leecode原题 题目 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 。 示例 示例 1: 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3 输出：[3,3,5,5,6,7] 解释： 滑动窗口的位置 最大值 --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 示例 2: 输入：nums = [1], k = 1 输出：[1] 提示： 1 -104 1 解题思路 思路 我们设计一个单调队列, 队列有以下三个主要接口: type MonotonicQueue interface{ //(滑动窗口中移除元素的数值) //如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作 Pop(value int) {} //(滑动窗口添加元素的数值) //如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止 Push(value int) // 获取队列队首元素 Front() int } 每次队列随着滑动窗口的移动，保持一出、一进的原则，该单调队列中的队头元素就是最大值。 设计单调队列的时候，pop，和push操作要保持如下规则： pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作 push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止 保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。 实现 源码 // 单调队列 type MonotonicQueue struct { queue []int //使用数组实现队列功能 } func NewMonotonicQueue() *MonotonicQueue { return &MonotonicQueue{queue: make([]int, 0)} } //(滑动窗口中移除元素的数值) //如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作 func (m *MonotonicQueue) Pop(value int) { if len(m.queue) > 0 && value == m.queue[0] { m.queue = m.queue[1:] } } //(滑动窗口添加元素的数值) //如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止 func (m *MonotonicQueue) Push(value int) { for len(m.queue) > 0 && value > m.queue[len(m.queue)-1] { m.queue = m.queue[:len(m.queue)-1] } // 添加到队尾 m.queue = append(m.queue, value) } // 获取队列队首元素 func (m *MonotonicQueue) Front() int { if len(m.queue) > 0 { return m.queue[0] } return 0 } // 滑动窗口最大值 func maxSlidingWindow(nums []int, k int) []int { numsLen := len(nums) maxArr := []int{} monotonicQueue := NewMonotonicQueue() // 先将第一个窗口元素全部塞入队列 for i := 0; i Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"stacks-queues/347-前K个高频元素.html":{"url":"stacks-queues/347-前K个高频元素.html","title":"347. 前 K 个高频元素","keywords":"","body":"347. 前 K 个高频元素 leecode原题 题目 给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。 示例 示例 1: 输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] 示例 2: 输入: nums = [1], k = 1 输出: [1] 提示： 1 k 的取值范围是 [1, 数组中不相同的元素的个数] 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的 解题思路 思路 实现 源码 // 使用快排实现 func topKFrequent(nums []int, k int) []int { res := []int{} // 使用map统计词频 countMap := make(map[int]int) for _, num := range nums { countMap[num]++ } for key, _ := range countMap { res = append(res, key) } //核心思想：排序 //可以不用包函数，自己实现快排 sort.Slice(res, func(a, b int) bool { return countMap[res[a]] > countMap[res[b]] }) return res[:k] } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/":{"url":"tree/","title":"二叉树","keywords":"","body":"树 Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/144-二叉树的前序遍历.html":{"url":"tree/144-二叉树的前序遍历.html","title":"144. 二叉树的前序遍历","keywords":"","body":"144. 二叉树的前序遍历 leecode原题 题目 给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 示例 示例 1: 输入：root = [1,null,2,3] 输出：[1,2,3] 示例 2: 输入：root = [] 输出：[] 示例 3: 输入：root = [1] 输出：[1] 示例 4: 输入：root = [1,2] 输出：[1,2] 示例 5: 输入：root = [1,null,2] 输出：[1,2] 提示： 树中节点数目在范围 [0, 100] 内 -100 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 解题思路 思路 递归实现 递归实现是比较简单的，记住根->左子树->右子树的遍历顺序即可，另外要当心golang里面切片传递的坑！ 迭代实现 借用栈搞定，其实也简单，详见代码，有详细步骤。 实现 源码 递归实现 func preorderTraversal(root *TreeNode) []int { nodeArr := make([]int, 0) traversal(root, &nodeArr) return nodeArr } func traversal(cur_node *TreeNode, arr *[]int) { if cur_node == nil { return } *arr = append(*arr, cur_node.Val) // fmt.Printf(\"%+v\\n\", cur_node.Val) traversal(cur_node.Left, arr) traversal(cur_node.Right, arr) } 层次遍历实现 type Stack struct { elements []*TreeNode } func NewStack() *Stack { return &Stack{elements: make([]*TreeNode, 0)} } func (s *Stack) IsEmpty() bool { if len(s.elements) == 0 { return true } return false } func (s *Stack) Push(element *TreeNode) { s.elements = append(s.elements, element) } func (s *Stack) Pop() *TreeNode { if !s.IsEmpty() { res := s.elements[len(s.elements)-1] s.elements = s.elements[:len(s.elements)-1] return res } return nil } // 迭代遍历 func preorderTraversal(root *TreeNode) []int { nodeArr := make([]int, 0) if root == nil { return nodeArr } s := NewStack() // 步骤1: 直到当前结点为空 & 栈空时，循环结束 for root != nil || !s.IsEmpty() { // 步骤2: 判断当前结点是否为空 if root != nil { // 步骤3: 保存当前节点值,并将该节点入栈 nodeArr = append(nodeArr, root.Val) s.Push(root) // 步骤4: 置当前结点的左孩子为当前节点 root = root.Left // 返回步骤1 } else { // 步骤5：出栈栈顶结点 root = s.Pop() // 步骤6：置当前结点的右孩子为当前节点 root = root.Right // 返回步骤1 } } return nodeArr } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/145-二叉树的后序遍历.html":{"url":"tree/145-二叉树的后序遍历.html","title":"145. 二叉树的后序遍历","keywords":"","body":"145. 二叉树的后序遍历 leecode原题 题目 给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。 示例 示例 1: 输入：root = [1,null,2,3] 输出：[3,2,1] 示例 2: 输入：root = [] 输出：[] 示例 3: 输入：root = [1] 输出：[1] 提示： 树中节点的数目在范围 [0, 100] 内 -100 解题思路 思路 递归实现 递归实现是比较简单的，记住左子树->右子树->根节点的遍历顺序即可，另外要当心golang里面切片传递的坑！ 迭代实现 借用栈搞定，其实也简单，详见代码，有详细步骤。 实现 源码递归实现 func postorderTraversal(root *TreeNode) []int { nodeArr := make([]int, 0) traversal(root, &nodeArr) return nodeArr } func traversal(cur_node *TreeNode, arr *[]int) { if cur_node == nil { return } traversal(cur_node.Left, arr) traversal(cur_node.Right, arr) *arr = append(*arr, cur_node.Val) } 迭代实现 // 用数据实现一个基本功能的栈 type Stack struct { elements []*TreeNode } func NewStack() *Stack { return &Stack{elements: make([]*TreeNode, 0)} } func (s *Stack) IsEmpty() bool { if len(s.elements) == 0 { return true } return false } func (s *Stack) Push(element *TreeNode) { s.elements = append(s.elements, element) } func (s *Stack) Pop() *TreeNode { if !s.IsEmpty() { res := s.elements[len(s.elements)-1] s.elements = s.elements[:len(s.elements)-1] return res } return nil } // 迭代遍历 func postorderTraversal(root *TreeNode) []int { nodeArr := make([]int, 0) if root == nil { return nodeArr } // 普通栈 s := NewStack() // 输出栈 out := NewStack() // 步骤1: 直到当前结点为空 & 栈空时，循环结束 for root != nil || !s.IsEmpty() { // 步骤2: 判断当前结点是否为空 if root != nil { // 步骤3: 将当前节点输入到普通栈和输出栈 s.Push(root) out.Push(root) // 步骤4: 置当前结点的右孩子为当前节点 root = root.Right // 返回步骤1 } else { // 步骤5：出栈栈顶结点 root = s.Pop() // 步骤6：置当前结点的左孩子为当前节点 root = root.Left // 返回步骤1 } } for !out.IsEmpty() { nodeArr = append(nodeArr, out.Pop().Val) } return nodeArr } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/94-二叉树的中序遍历.html":{"url":"tree/94-二叉树的中序遍历.html","title":"94. 二叉树的中序遍历","keywords":"","body":"94. 二叉树的中序遍历 leecode原题 题目 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。 示例 示例 1: 输入：root = [1,null,2,3] 输出：[1,3,2] 示例 2: 输入：root = [] 输出：[] 示例 3: 输入：root = [1] 输出：[1] 提示： 树中节点数目在范围 [0, 100] 内 -100 进阶 递归算法很简单，你可以通过迭代算法完成吗？ 解题思路 思路 递归实现 递归实现是比较简单的，记住左子树->根节点->右子树的遍历顺序即可，另外要当心golang里面切片传递的坑！ 迭代实现 借用栈搞定，其实也简单，详见代码，有详细步骤。 实现 源码 递归实现 func inorderTraversal(root *TreeNode) []int { nodeArr := make([]int, 0) traversal(root, &nodeArr) return nodeArr } func traversal(cur_node *TreeNode, arr *[]int) { if cur_node == nil { return } traversal(cur_node.Left, arr) *arr = append(*arr, cur_node.Val) traversal(cur_node.Right, arr) } 迭代实现 type Stack struct { elements []*TreeNode } func NewStack() *Stack { return &Stack{elements: make([]*TreeNode, 0)} } func (s *Stack) IsEmpty() bool { if len(s.elements) == 0 { return true } return false } func (s *Stack) Push(element *TreeNode) { s.elements = append(s.elements, element) } func (s *Stack) Pop() *TreeNode { if !s.IsEmpty() { res := s.elements[len(s.elements)-1] s.elements = s.elements[:len(s.elements)-1] return res } return nil } // 迭代遍历 func inorderTraversal(root *TreeNode) []int { nodeArr := make([]int, 0) if root == nil { return nodeArr } s := NewStack() // 步骤1: 直到当前结点为空 & 栈空时，循环结束 for root != nil || !s.IsEmpty() { // 步骤2: 判断当前结点是否为空 if root != nil { // 步骤3: 将该节点入栈 s.Push(root) // 步骤4: 置当前结点的左孩子为当前节点 root = root.Left // 返回步骤1 } else { // 步骤5：出栈栈顶结点 root = s.Pop() // 步骤6：保存节点 nodeArr = append(nodeArr, root.Val) // 步骤7：置当前结点的右孩子为当前节点 root = root.Right // 返回步骤1 } } return nodeArr } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/102-二叉树的层序遍历.html":{"url":"tree/102-二叉树的层序遍历.html","title":"102. 二叉树的层序遍历","keywords":"","body":"102. 二叉树的层序遍历 leecode原题 题目 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。 示例 1： 示例 示例 1: 输入：root = [3,9,20,null,null,15,7] 输出：[[3],[9,20],[15,7]] 示例 2: 输入：root = [1] 输出：[[1]] 示例 3: 输入：root = [] 输出：[] 提示： 树中节点数目在范围 [0, 2000] 内 -1000 解题思路 思路 这套题是典型的层次遍历题，可以用作模板解决其它类型的问题。 该题的关键点在于: 层次遍历这种情况，我们需要借助队列实现即可。重点要诀: 每一次循环将该层元素全部送入队列后，记住当前队列队列长度，然后依次弹出队列元素(弹出队列长度N个元素), 并且在弹出元素的时候，将该元素的左右子树(判断非空)依次送入队列。更详细的可以看代码, 很容易就看明白了。 实现 源码 // 用数组实现个简单的队列功能 type Queue struct { elements []*TreeNode } func NewQueue() *Queue { return &Queue{elements: make([]*TreeNode, 0)} } func (q *Queue) Push(node *TreeNode) { q.elements = append(q.elements, node) } func (q *Queue) Pop() *TreeNode { if q.IsEmpty() { return nil } node := q.elements[0] q.elements = q.elements[1:] return node } func (q *Queue) Size() int { return len(q.elements) } func (q *Queue) IsEmpty() bool { if q.Size() == 0 { return true } return false } func levelOrder(root *TreeNode) [][]int { if root == nil { return nil } nodeArr := make([][]int, 0) q := NewQueue() // 头元素先送入队列 q.Push(root) for !q.IsEmpty() { currentLevelNodeArr := make([]int, 0) qSize := q.Size() // 代表当前这一层的元素， 一定要先取出size, q.Size()会一直变化 for i := 0; i Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/226-翻转二叉树.html":{"url":"tree/226-翻转二叉树.html","title":"226. 翻转二叉树","keywords":"","body":"226. 翻转二叉树 leecode原题 题目 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 示例 示例 1: 输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1] 示例 2: 输入：root = [2,1,3] 输出：[2,3,1] 示例 3: 输入：root = [] 输出：[] 提示： 树中节点数目范围在 [0, 100] 内 -100 解题思路 思路 该题有很多种解法，这里就直接用层次遍历的方式解决了。 该题跟102.二叉树的层序遍历是类似的可以采用层次遍历，只不过需要在遍历的过程中，交换每个节点的左右节点即可。 实现 源码 // 用数组实现个简单的队列功能 type Queue struct { elements []*TreeNode } func NewQueue() *Queue { return &Queue{elements: make([]*TreeNode, 0)} } func (q *Queue) Push(node *TreeNode) { q.elements = append(q.elements, node) } func (q *Queue) Pop() *TreeNode { if q.IsEmpty() { return nil } node := q.elements[0] q.elements = q.elements[1:] return node } func (q *Queue) Size() int { return len(q.elements) } func (q *Queue) IsEmpty() bool { if q.Size() == 0 { return true } return false } func invertTree(root *TreeNode) *TreeNode { if root == nil { return nil } q := NewQueue() q.Push(root) for !q.IsEmpty() { qSize := q.Size() // 代表当前这一层的元素， 一定要先取出size, q.Size()会一直变化 for i := 0; i Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/101-对称二叉树.html":{"url":"tree/101-对称二叉树.html","title":"101. 对称二叉树","keywords":"","body":"101. 对称二叉树 leecode原题 题目 给你一个二叉树的根节点 root ， 检查它是否轴对称。 示例 示例 1: 输入：root = [1,2,2,3,4,4,3] 输出：true 示例 2: 输入：root = [1,2,2,null,3,null,3] 输出：false 提示： 树中节点数目在范围 [1, 1000] 内 -100 解题思路 思路 首先想清楚，判断对称二叉树要比较的是哪两个节点，要比较的可不是左右节点！ 对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了其实我们要比较的是两个树（这两个树是根节点的左右子树），所以在递归遍历的过程中，也是要同时遍历两棵树。 那么如果比较呢？ 比较的是两个子树的里侧和外侧的元素是否相等。如图所示： 该题的核心就是比较每个子树的里侧和外侧的元素是否相等，也即比较(leftTree.Left, rightTree.Right)和(leftTree.Right, rightTree.left), 然后要注意判断终止条件: 即左右子树为空和非空时候的判断依据。 实现 源码 递归法实现 type TreeNode struct { Val int Left *TreeNode Right *TreeNode } func compareTree(left *TreeNode, right *TreeNode) bool { // 判断节点为空的情况 if left == nil && right == nil { return true } if left == nil || right == nil { return false } // 节点非空，比较值是否相等 if left.Val != right.Val { return false } return compareTree(left.Left, right.Right) && compareTree(left.Right, right.Left) } // 递归法实现 func isSymmetric(root *TreeNode) bool { return compareTree(root.Left, root.Right) } 迭代法实现: type TreeNode struct { Val int Left *TreeNode Right *TreeNode } func isSymmetric1(root *TreeNode) bool { queue := []*TreeNode{} if root != nil { queue = append(queue, root.Left, root.Right) } for len(queue) != 0 { left := queue[0] right := queue[1] queue = queue[2:] // 节点为空的情况下 if left == nil && right == nil { continue } if left == nil || right == nil { return false } // 节点非空的情况下 if left.Val != right.Val { return false } // 重点步骤!!!思路跟递归其实是类似的 queue = append(queue, left.Left, right.Right, left.Right, right.Left) } return true } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/104-二叉树的最大深度.html":{"url":"tree/104-二叉树的最大深度.html","title":"104. 二叉树的最大深度","keywords":"","body":"104. 二叉树的最大深度 leecode原题 题目 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例 示例 1: 给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7 返回它的最大深度 3 。 解题思路 思路 这题可以用层次遍历思路来求解(遍历完每一层，高度加1即可)，可以参阅二叉树的层序遍历 实现 源码 // 用数组实现个简单的队列功能 type Queue struct { elements []*TreeNode } func NewQueue() *Queue { return &Queue{elements: make([]*TreeNode, 0)} } func (q *Queue) Push(node *TreeNode) { q.elements = append(q.elements, node) } func (q *Queue) Pop() *TreeNode { if q.IsEmpty() { return nil } node := q.elements[0] q.elements = q.elements[1:] return node } func (q *Queue) Size() int { return len(q.elements) } func (q *Queue) IsEmpty() bool { if q.Size() == 0 { return true } return false } func maxDepth(root *TreeNode) int { if root == nil { return 0 } q := NewQueue() q.Push(root) maxDepth := 0 for !q.IsEmpty() { qSize := q.Size() // 代表当前这一层的元素， 一定要先取出size, q.Size()会一直变化 for i := 0; i Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/111-二叉树的最小深度.html":{"url":"tree/111-二叉树的最小深度.html","title":"111. 二叉树的最小深度","keywords":"","body":"111. 二叉树的最小深度 leecode原题 题目 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 说明: 叶子节点是指没有子节点的节点。 示例 示例 1: 输入：root = [3,9,20,null,null,15,7] 输出：2 示例 2: 输入：root = [2,null,3,null,4,null,5,null,6] 输出：5 提示： 树中节点数的范围在 [0, 105] 内 -1000 解题思路 思路 这题可以用层次遍历思路来求解(每遍历一层, 判断该层节点的左右子树节点，如果左右子树节点都为空，即代表找到最小深度)，可以参阅二叉树的层序遍历 实现 源码 type TreeNode struct { Val int Left *TreeNode Right *TreeNode } // 用数组实现个简单的队列功能 type Queue struct { elements []*TreeNode } func NewQueue() *Queue { return &Queue{elements: make([]*TreeNode, 0)} } func (q *Queue) Push(node *TreeNode) { q.elements = append(q.elements, node) } func (q *Queue) Pop() *TreeNode { if q.IsEmpty() { return nil } node := q.elements[0] q.elements = q.elements[1:] return node } func (q *Queue) Size() int { return len(q.elements) } func (q *Queue) IsEmpty() bool { if q.Size() == 0 { return true } return false } func minDepth(root *TreeNode) int { if root == nil { return 0 } q := NewQueue() q.Push(root) minDepth := 0 for !q.IsEmpty() { qSize := q.Size() // 代表当前这一层的元素， 一定要先取出size, q.Size()会一直变化 for i := 0; i Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/222-完全二叉树的节点个数.html":{"url":"tree/222-完全二叉树的节点个数.html","title":"222. 完全二叉树的节点个数","keywords":"","body":"222. 完全二叉树的节点个数 leecode原题 题目 给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。 完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。 示例 示例 1: 输入：root = [1,2,3,4,5,6] 输出：6 示例 2: 输入：root = [] 输出：0 示例 3: 输入：root = [1] 输出：1 提示： 树中节点的数目范围是[0, 5 * 104] 0 题目数据保证输入的树是完全二叉树 进阶: 遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗？ 解题思路 思路 这题可以用层次遍历思路来求解(每遍历一层, 节点总数加上该层的节点数据)，可以参阅二叉树的层序遍历 实现 源码 // 用数组实现个简单的队列功能 type Queue struct { elements []*TreeNode } func NewQueue() *Queue { return &Queue{elements: make([]*TreeNode, 0)} } func (q *Queue) Push(node *TreeNode) { q.elements = append(q.elements, node) } func (q *Queue) Pop() *TreeNode { if q.IsEmpty() { return nil } node := q.elements[0] q.elements = q.elements[1:] return node } func (q *Queue) Size() int { return len(q.elements) } func (q *Queue) IsEmpty() bool { if q.Size() == 0 { return true } return false } func countNodes(root *TreeNode) int { if root == nil { return 0 } q := NewQueue() q.Push(root) nodeSum := 0 for !q.IsEmpty() { qSize := q.Size() // 代表当前这一层的元素， 一定要先取出size, q.Size()会一直变化 nodeSum += qSize for i := 0; i Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/110-平衡二叉树.html":{"url":"tree/110-平衡二叉树.html","title":"110. 平衡二叉树","keywords":"","body":"110. 平衡二叉树 leecode原题 题目 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。 示例 示例 1: 输入：root = [3,9,20,null,null,15,7] 输出：true 示例 2: 输入：root = [1,2,2,3,3,null,null,4,4] 输出：false 示例 3: 输入：root = [] 输出：true 提示： 树中的节点数在范围 [0, 5000] 内 -104 解题思路 思路 实现 源码 func max(a, b int) int { if a > b { return a } return b } func abs(num int) int { if num 1 { return false } return true } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/257-二叉树的所有路径.html":{"url":"tree/257-二叉树的所有路径.html","title":"257. 二叉树的所有路径","keywords":"","body":"257. 二叉树的所有路径 leecode原题 题目 给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。 叶子节点 是指没有子节点的节点。 示例 示例 1: 输入：root = [1,2,3,null,5] 输出：[\"1->2->5\",\"1->3\"] 示例 2: 输入：root = [1] 输出：[\"1\"] 提示： 树中节点的数目在范围 [1, 100] 内 -100 解题思路 思路 仔细想一想就是前序遍历的变种，在前序递归的过程中，记录当前递归到的路径，并传到到下一个递归中，遇到叶子节点的时候，才将最终的路径追加到数组中。 实现 源码 递归法 func travel(root *TreeNode, res *[]string, s string) { // 如果是叶子结果, 添加路径到数组中 if root.Left == nil && root.Right == nil { *res = append(*res, s+strconv.Itoa(root.Val)) return } // 其实就是前序遍历的变种 s = s + strconv.Itoa(root.Val) + \"->\" if root.Left != nil { travel(root.Left, res, s) } if root.Right != nil { travel(root.Right, res, s) } } // 递归法实现 func binaryTreePaths(root *TreeNode) []string { if root == nil { return nil } res := make([]string, 0) travel(root, &res, \"\") return res } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/404-左叶子之和.html":{"url":"tree/404-左叶子之和.html","title":"404. 左叶子之和","keywords":"","body":"404. 左叶子之和 leecode原题 题目 给定二叉树的根节点 root ，返回所有左叶子之和。 示例 示例 1: 输入: root = [3,9,20,null,null,15,7] 输出: 24 解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 示例 2: 输入: root = [1] 输出: 0 提示： 节点数在 [1, 1000] 范围内 -1000 解题思路 思路 左叶子的明确定义：节点A的左孩子不为空，且左孩子的左右孩子都为空（说明是叶子节点），那么A节点的左孩子为左叶子节点 实现 源码 type TreeNode struct { Val int Left *TreeNode Right *TreeNode } func travel(root *TreeNode, res *int) { // 判断是左叶子节点 // 这里条件很重要!!!!!, 主要是判断左叶子节点 if root.Left != nil && root.Left.Left == nil && root.Left.Right == nil { *res = *res + root.Left.Val } if root.Left != nil { travel(root.Left, res) } if root.Right != nil { travel(root.Right, res) } } func sumOfLeftLeaves(root *TreeNode) int { res := 0 if root == nil { return res } travel(root, &res) return res } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/513-找树左下角的值.html":{"url":"tree/513-找树左下角的值.html","title":"513. 找树左下角的值","keywords":"","body":"513. 找树左下角的值 leecode原题 题目 给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 示例 示例 1: 输入: root = [2,1,3] 输出: 1 示例 2: 输入: [1,2,3,4,null,5,6,null,null,7] 输出: 7 提示： 二叉树的节点个数的范围是 [1,104] -231 解题思路 思路 这题可以用层次遍历思路来求解(每遍历一层, 队列中当前第一个元素就是该层最左元素，最后一次遍历就是最底层的最左元素)，可以参阅二叉树的层序遍历 实现 源码 // 用数组实现个简单的队列功能 type Queue struct { elements []*TreeNode } func NewQueue() *Queue { return &Queue{elements: make([]*TreeNode, 0)} } func (q *Queue) Push(node *TreeNode) { q.elements = append(q.elements, node) } func (q *Queue) Pop() *TreeNode { if q.IsEmpty() { return nil } node := q.elements[0] q.elements = q.elements[1:] return node } func (q *Queue) Size() int { return len(q.elements) } func (q *Queue) IsEmpty() bool { if q.Size() == 0 { return true } return false } func findBottomLeftValue(root *TreeNode) int { if root == nil { return 0 } q := NewQueue() q.Push(root) bottomLeftVal := 0 for !q.IsEmpty() { qSize := q.Size() for i := 0; i Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/112-路径总和.html":{"url":"tree/112-路径总和.html","title":"112. 路径总和","keywords":"","body":"112. 路径总和 leecode原题 题目 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。 叶子节点: 是指没有子节点的节点。 示例 示例 1: 输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 输出：true 解释：等于目标和的根节点到叶节点路径如上图所示。 示例 2: 输入：root = [1,2,3], targetSum = 5 输出：false 解释：树中存在两条根节点到叶子节点的路径： (1 --> 2): 和为 3 (1 --> 3): 和为 4 不存在 sum = 5 的根节点到叶子节点的路径。 示例 3: 输入：root = [], targetSum = 0 输出：false 解释：由于树是空的，所以不存在根节点到叶子节点的路径。 提示： 树中节点的数目在范围 [0, 5000] 内 -1000 -1000 解题思路 思路 这题跟257. 二叉树的所有路径类似，也是可以采用前序遍历实现, 只需要到叶子节点出判断累加和是否等于目标值。 实现 源码 func travel(root *TreeNode, targetSum int, sum int) bool { if root == nil { return false } // 是叶子节点 if root.Left == nil && root.Right == nil { sum += root.Val if sum == targetSum { return true } return false } sum += root.Val return travel(root.Left, targetSum, sum) || travel(root.Right, targetSum, sum) } func hasPathSum(root *TreeNode, targetSum int) bool { sum := 0 return travel(root, targetSum, sum) } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/106-从中序与后序遍历序列构造二叉树.html":{"url":"tree/106-从中序与后序遍历序列构造二叉树.html","title":"106. 从中序与后序遍历序列构造二叉树","keywords":"","body":"106. 从中序与后序遍历序列构造二叉树 leecode原题 题目 给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。 示例 示例 1: 输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3] 输出：[3,9,20,null,null,15,7] 示例 2: 输入：inorder = [-1], postorder = [-1] 输出：[-1] 提示： 1 postorder.length == inorder.length -3000 inorder 和 postorder 都由 不同 的值组成 postorder 中每一个值都在 inorder 中 inorder 保证是树的中序遍历 postorder 保证是树的后序遍历 解题思路 思路 以后序数组的最后一个元素为切割点(后序数组的最后一个元素总是根节点)，找到该切割点在中序数组中的索引下标, 将中序和后序数组以切割点下标一分为二(这里要尤其主要边界)，然后一次以分割后的中序和后续数组的左半数组和右半数组依次作为左右子树进行递归构建。 说到一层一层切割，就应该想到了递归。 来看一下一共分几步： 第一步：如果数组大小为零的话，说明是空节点了。 第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。 第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点 第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组） 第五步：切割后序数组，切成后序左数组和后序右数组 第六步：递归处理左区间和右区间 实现 源码 func buildTree(inorder []int, postorder []int) *TreeNode { // 节点为空 if len(inorder) == 0 || len(postorder) == 0 { return nil } // 找到后序数组最后一个元素(就是子树的根节点)在中序数组中的下标, 然后进行二分 pos := findInorderPos(inorder, postorder[len(postorder)-1]) // 这里一定要注意边界!!! root := &TreeNode{ Left: buildTree(inorder[:pos], postorder[:pos]), Right: buildTree(inorder[pos+1:], postorder[pos:len(postorder)-1]), Val: inorder[pos], } return root } // 找中序目标值的索引位置 func findInorderPos(inorder []int, target int) int { for index, v := range inorder { if v == target { return index } } return -1 } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/654-最大二叉树.html":{"url":"tree/654-最大二叉树.html","title":"654. 最大二叉树","keywords":"","body":"654. 最大二叉树 leecode原题 题目 给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建: 创建一个根节点，其值为 nums 中的最大值。 递归地在最大值左边的子数组前缀上构建左子树。 递归地在最大值右边的子数组后缀上构建右子树。 返回 nums 构建的最大二叉树。 示例 示例 1: 输入：nums = [3,2,1,6,0,5] 输出：[6,3,5,null,2,0,null,null,1] 解释：递归调用如下所示： - [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。 - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 - 空数组，无子节点。 - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。 - 空数组，无子节点。 - 只有一个元素，所以子节点是一个值为 1 的节点。 - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。 - 只有一个元素，所以子节点是一个值为 0 的节点。 - 空数组，无子节点。 示例 2: 输入：nums = [3,2,1] 输出：[3,null,2,null,1] 提示： 1 0 nums 中的所有整数互不相同 解题思路 思路 该题理解后，其实也是比较简单的，每次找到数组中的最大值索引，然后以该索引为切割点继续将数组一分为二，递归切分后的左右数组分别形成左右子树即可。 实现 源码 func constructMaximumBinaryTree(nums []int) *TreeNode { // 数组为空，终止 if len(nums) == 0 { return nil } maxIndex := findMaxValIndex(nums) // 将数组一分为二, 依次递归 root := &TreeNode{ Left: constructMaximumBinaryTree(nums[:maxIndex]), Right: constructMaximumBinaryTree(nums[maxIndex+1:]), Val: nums[maxIndex], } return root } // 找寻最大值的下标 func findMaxValIndex(nums []int) (index int) { if len(nums) == 0 { return -1 } max := nums[0] for i := 1; i max { max = nums[i] index = i } } return index } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/617-合并二叉树.html":{"url":"tree/617-合并二叉树.html","title":"617. 合并二叉树","keywords":"","body":"617. 合并二叉树 leecode原题 题目 给你两棵二叉树： root1 和 root2 。 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。 返回合并后的二叉树。 注意: 合并过程必须从两个树的根节点开始。 示例 示例 1: 输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7] 输出：[3,4,5,5,4,null,7] 示例 2: 输入：root1 = [1], root2 = [1,2] 输出：[2,2] 提示： 两棵树中的节点数目在范围 [0, 2000] 内 -104 解题思路 可以采用前序遍历实现, 同时前序遍历两棵子树, 如果都非空，则新子树根节点的值为两棵子树根节点值之和，否和只要有一边子树为空，则新子树直接为另一非空子树。 思路 实现 源码 // 递归实现 func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode { // 只有一边的情况下, 直接返回另一边 if root1 == nil { return root2 } if root2 == nil { return root1 } root := &TreeNode{ Left: mergeTrees(root1.Left, root2.Left), Right: mergeTrees(root1.Right, root2.Right), Val: root1.Val + root2.Val, // 节点值相加 } return root } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/700-二叉搜索树中的搜索.html":{"url":"tree/700-二叉搜索树中的搜索.html","title":"700. 二叉搜索树中的搜索","keywords":"","body":"700. 二叉搜索树中的搜索 leecode原题 题目 给定二叉搜索树（BST）的根节点 root 和一个整数值 val。 你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。 示例 示例 1: 输入：root = [4,2,7,1,3], val = 2 输出：[2,1,3] 示例 2: 输入：root = [4,2,7,1,3], val = 5 输出：[] 提示： 数中节点数在 [1, 5000] 范围内 1 root 是二叉搜索树 1 解题思路 思路 二叉搜索树是一个有序树： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉搜索树 这就决定了，二叉搜索树，递归遍历和迭代遍历和普通二叉树都不一样。 核心解法:根据二叉树的特性, 可以比较根节点和目标值的大小关系，如果相等即找到目标树，如果大于目标值，则递归找左子树，如果小于目标值，则递归找右子树。 实现 源码 func searchBST(root *TreeNode, val int) *TreeNode { if root == nil { return nil } // 找到目标树 if root.Val == val { return root } // 左子树非空，并且左子树根节点大于目标值(左子树值均小于根节点值) if root.Left != nil && root.Val > val { return searchBST(root.Left, val) } // 右子树非空，并且右子树根节点小于于目标值(右子树值均大于根节点值) if root.Right != nil && root.Val Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/98-验证二叉搜索树.html":{"url":"tree/98-验证二叉搜索树.html","title":"98. 验证二叉搜索树","keywords":"","body":"98. 验证二叉搜索树 leecode原题 题目 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 有效二叉搜索树定义如下： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 示例 1: 输入：root = [2,1,3] 输出：true 示例 2: 输入：root = [5,1,4,null,null,3,6] 输出：false 解释：根节点的值是 5 ，但是右子节点的值是 4 。 提示： 树中节点数目范围在[1, 104] 内 -231 解题思路 思路 陷阱: 不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了。我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点。 也就是递归的过程中，左子树的最大值，右子树的最小值要不停的变更为当前跟根节点的值。 实现 源码 func isValidBST(root *TreeNode) bool { return check(root, math.MinInt64, math.MaxInt64) } func check(root *TreeNode, min, max int) bool { // 为空，也是有效的 if root == nil { return true } if root.Val = max { return false } // 这里很重要！！！！, 所有左子树的值必须小于当前根节点, 右子树的值必须大于当前根节点 return check(root.Left, min, root.Val) && check(root.Right, root.Val, max) } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/530-二叉搜索树的最小绝对差.html":{"url":"tree/530-二叉搜索树的最小绝对差.html","title":"530. 二叉搜索树的最小绝对差","keywords":"","body":"530. 二叉搜索树的最小绝对差 leecode原题 题目 给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。 差值是一个正数，其数值等于两值之差的绝对值。 示例 示例 1: 输入：root = [4,2,6,1,3] 输出：1 示例 2: 输入：root = [1,0,48,null,null,12,49] 输出：1 提示： 树中节点的数目范围是 [2, 104] 0 解题思路 思路 题目中要求在二叉搜索树上任意两节点的差的绝对值的最小值。 注意是二叉搜索树，二叉搜索树可是有序的。 遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个有序数组上求最值，求差值，这样就简单多了。 那么二叉搜索树采用中序遍历，其实就是一个有序数组。 实现 源码 type TreeNode struct { Val int Left *TreeNode Right *TreeNode } // 中序遍历 func inorderTravel(root *TreeNode, arr *[]int) { if root == nil { return } // 遍历左子树 inorderTravel(root.Left, arr) // 访问根节点 *arr = append(*arr, root.Val) // 遍历右子树 inorderTravel(root.Right, arr) } func getMinimumDifference(root *TreeNode) int { // 利用二叉搜索树和中序遍历的特性，可以采用中序遍历，得到一个有序的数组 arr := make([]int, 0) // 中序遍历后得到一个有序的数组 inorderTravel(root, &arr) minValue := math.MaxInt64 for i := 1; i Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/501-二叉搜索树中的众数.html":{"url":"tree/501-二叉搜索树中的众数.html","title":"501. 二叉搜索树中的众数","keywords":"","body":"501. 二叉搜索树中的众数 leecode原题 题目 给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。 如果树中有不止一个众数，可以按任意顺序返回。 假定 BST 满足如下定义： 结点左子树中所含节点的值 小于等于 当前节点的值 结点右子树中所含节点的值 大于等于 当前节点的值 左子树和右子树都是二叉搜索树 示例 示例 1: 输入：root = [1,null,2,2] 输出：[2] 示例 2: 输入：root = [0] 输出：[0] 提示： 树中节点的数目在范围 [1, 104] 内 105 进阶: 你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内） 解题思路 思路 如果不考虑不使用额外的空间，不做的优化的话，那本身随便用一个遍历方式，遍历完树，得到所有的元素值，然后可以使用map统计所有值出现的频率，然后排序即可解决。 但是要考虑不使用额外空间的话，那么我们就需要在一次中序遍历中(二叉搜索树在中序遍历中是有序的!!!!)，完成这个操作，可以记录一个Pre指针指向上一个节点，然后每次遍历用当前指针跟上一个指针的值进行比较, 记录即可。 实现 源码 func findMode(root *TreeNode) []int { var ( res = make([]int, 0) maxCount = 0 // 最大统计数 count = 0 pre *TreeNode travel func(root *TreeNode) ) travel = func(root *TreeNode) { // 二叉搜索树通过中序遍历能得到有序数组 if root == nil { return } // 遍历左子树 travel(root.Left) // 处理根节点 if pre == nil { // 第一个节点 count = 1 } else if root.Val == pre.Val { // 与前一个节点数值相同 count += 1 } else { count = 1 // 与前一个节点数值不同 } pre = root // 更新上一个节点 if count == maxCount { // 要考虑一下存在相同的情况, 比如有两个值，一个1，一个2， 这个时候应该返回[1, 2] res = append(res, root.Val) } if count > maxCount { //大于记录的最大值, 这个时候res数组需要重置 maxCount = count res = make([]int, 0) //!!!!数组重置 res = append(res, root.Val) } // 遍历右子树 travel(root.Right) } travel(root) return res } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/236-二叉树的最近公共祖先.html":{"url":"tree/236-二叉树的最近公共祖先.html","title":"236. 二叉树的最近公共祖先","keywords":"","body":"236. 二叉树的最近公共祖先 leecode原题 题目 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 示例 示例 1: 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出：3 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。 示例 2: 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出：5 解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。 示例 3: 输入：root = [1,2], p = 1, q = 2 输出：1 提示： 树中节点数目在范围 [2, 105] 内。 -109 所有 Node.val 互不相同 。 p != q p 和 q 均存在于给定的二叉树中。 解题思路 思路 实现 源码 func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { // 遍历为空或者找到目标点 if root == nil || root == p || root == q { return root } left := lowestCommonAncestor(root.Left, p, q) rigth := lowestCommonAncestor(root.Right, p, q) // 如果left和rigth都不为空，代表找到祖先节点 if left != nil && rigth != nil { return root } if left != nil { return left } if rigth != nil { return rigth } return nil } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/701-二叉搜索树中的插入操作.html":{"url":"tree/701-二叉搜索树中的插入操作.html","title":"701. 二叉搜索树中的插入操作","keywords":"","body":"701. 二叉搜索树中的插入操作 leecode原题 题目 给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。 注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。 示例 示例 1: 输入：root = [4,2,7,1,3], val = 5 输出：[4,2,7,1,3,5] 解释：另一个满足题目要求可以通过的树是： 示例 2: 输入：root = [40,20,60,10,30,50,70], val = 25 输出：[40,20,60,10,30,50,70,null,null,25] 示例 3: 输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5 输出：[4,2,7,1,3,5] 提示： 树中的节点数将在 [0, 104]的范围内。 -108 所有值 Node.val 是 独一无二 的。 -108 保证 val 在原始BST中不存在。 解题思路 思路 其实可以不考虑题目中提示所说的改变树的结构的插入方式。 核心思路: 只要按照二叉搜索树的规则去遍历，遇到空节点就插入节点就可以了。 实现 源码 func insertIntoBST(root *TreeNode, val int) *TreeNode { if root == nil { root = &TreeNode{ Val: val, } return root } if val root.Val { root.Right = insertIntoBST(root.Right, val) } return root } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/450-删除二叉搜索树中的节点.html":{"url":"tree/450-删除二叉搜索树中的节点.html","title":"450. 删除二叉搜索树中的节点","keywords":"","body":"450. 删除二叉搜索树中的节点 leecode原题 题目 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。 一般来说，删除节点可分为两个步骤： 首先找到需要删除的节点； 如果找到了，删除它。 示例 示例 1: 输入：root = [5,3,6,2,4,null,7], key = 3 输出：[5,4,6,2,null,null,7] 解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。 一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。 另一个正确答案是 [5,2,6,null,4,null,7]。 示例 2: 输入: root = [5,3,6,2,4,null,7], key = 0 输出: [5,3,6,2,4,null,7] 解释: 二叉树不包含值为 0 的节点 示例 3: 输入: root = [], key = 0 输出: [] 提示： 节点数的范围 [0, 104]. -105 节点值唯一 root 是合法的二叉搜索树 -105 解题思路 思路 这里就把二叉搜索树中删除节点遇到的情况都搞清楚。 有以下五种情况： 第一种情况：没找到删除的节点，遍历到空节点直接返回了 找到删除的节点 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点 第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点 第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点 第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。 总体来说，第5种情况，相对会复杂些。 实现 源码 func deleteNode(root *TreeNode, key int) *TreeNode { // 没找到 if root == nil { return root } // 找到目标值 if root.Val == key { // 节点的左右子树均为空，即该节点为叶子节点，舍弃即可 if root.Left == nil && root.Right == nil { return nil } // 左子树为空，右子树非空, 右子树替换该节点 if root.Left == nil && root.Right != nil { return root.Right } // 左子树非空，右子树为空，左子树替换该节点 if root.Left != nil && root.Right == nil { return root.Left } // 左右子树均非空 if root.Left != nil && root.Right != nil { // 找到右子树的最左叶子节点, 将左子树作为最左叶子节点的左子树插入 tmp := root.Right for tmp.Left != nil { tmp = tmp.Left } tmp.Left = root.Left // 原节点左子树置空 root.Left = nil // 原节点用右子树替换 root = root.Right return root } } // 寻找左子树 if key Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/669-修剪二叉搜索树.html":{"url":"tree/669-修剪二叉搜索树.html","title":"669. 修剪二叉搜索树","keywords":"","body":"669. 修剪二叉搜索树 leecode原题 题目 给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。 所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。 示例 示例 1: 输入：root = [1,0,2], low = 1, high = 2 输出：[1,null,2] 示例 2: 输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3 输出：[3,2,null,1] 提示： 树中节点数在范围 [1, 104] 内 0 树中每个节点的值都是 唯一 的 题目数据保证输入是一棵有效的二叉搜索树 0 解题思路 思路 这道题代码简单，但是理解起来不是很好理解，最好照着实现代码模拟一遍，就明白了。 实现 源码 func trimBST(root *TreeNode, low int, high int) *TreeNode { if root == nil { return root } // 寻找符合区间[low, high]的节点 if root.Val high { return trimBST(root.Left, low, high) } root.Left = trimBST(root.Left, low, high) // root->left接入符合条件的左孩子 root.Right = trimBST(root.Right, low, high) // root->left接入符合条件的右孩子 return root } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/108-将有序数组转换为二叉搜索树.html":{"url":"tree/108-将有序数组转换为二叉搜索树.html","title":"108. 将有序数组转换为二叉搜索树","keywords":"","body":"108. 将有序数组转换为二叉搜索树 leecode原题 题目 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。 高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。 示例 示例 1: 输入：nums = [-10,-3,0,5,9] 输出：[0,-3,9,-10,null,5] 解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案： 示例 2: 输入：nums = [1,3] 输出：[3,1] 解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。 提示： 1 -104 nums 按 严格递增 顺序排列 解题思路 思路 这道题其实要构建的二叉树平衡度不超过1，那么本身数组也就是绝对有序的，我们只需要结合二分法，每次将数组从中间切割开， 中间元素值作为节点值，然后左，右数组依次递归，且作为该节点的左右子树即可。 实现 源码 func travel(nums []int, left, right int) *TreeNode { if left > right { return nil } // 每次二分, 中间节点 mid := left + (right-left)/2 root := &TreeNode{ Val: nums[mid], } root.Left = travel(nums, left, mid-1) root.Right = travel(nums, mid+1, right) return root } func sortedArrayToBST(nums []int) *TreeNode { if len(nums) == 0 { return nil } root := travel(nums, 0, len(nums)-1) return root } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"tree/538-把二叉搜索树转换为累加树.html":{"url":"tree/538-把二叉搜索树转换为累加树.html","title":"538. 把二叉搜索树转换为累加树","keywords":"","body":"538. 把二叉搜索树转换为累加树 leecode原题 题目 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。 提醒一下，二叉搜索树满足下列约束条件： 节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。 示例 示例 1: 输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] 输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] 示例 2: 输入：root = [0,null,1] 输出：[1,null,1] 示例 3: 输入：root = [1,0,2] 输出：[3,3,2] 示例 4: 输入：root = [3,2,4,1] 输出：[7,9,4,10] 提示： 树中的节点数介于 0 和 104 之间。 每个节点的值介于 -104 和 104 之间。 树中的所有值 互不相同 。 给定的树为二叉搜索树。 解题思路 思路 二叉搜索树，是有序的。那么有序的元素如果求累加呢？ 其实这就是一棵树，大家可能看起来有点别扭，换一个角度来看，这就是一个有序数组[2, 5, 13]，求从后到前的累加数组，也就是[20, 18, 13]，是不是感觉这就简单了。 为什么变成数组就是感觉简单了呢？ 因为数组大家都知道怎么遍历啊，从后向前，挨个累加就完事了，这换成了二叉搜索树，看起来就别扭了一些是不是。 那么知道如何遍历这个二叉树，也就迎刃而解了，从树中可以看出累加的顺序是右中左(!!!!!)，所以我们需要反中序遍历这个二叉树，然后顺序累加就可以了 实现 源码 func travel(root *TreeNode, sum *int) { // 为空，结束该次递归，开始返回 if root == nil { return } // 针对二叉搜索树，按照右、中、左的顺序遍历, 即可实现累加 // 遍历右子树 travel(root.Right, sum) // 处理根节点 *sum = *sum + root.Val root.Val = *sum // 遍历左子树 travel(root.Left, sum) } func convertBST(root *TreeNode) *TreeNode { var sum int = 0 travel(root, &sum) return root } Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"backtracking/":{"url":"backtracking/","title":"回溯算法","keywords":"","body":"回溯算法 Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"backtracking/77-组合.html":{"url":"backtracking/77-组合.html","title":"77. 组合","keywords":"","body":"77. 组合 leecode原题 题目 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k个数的组合。 你可以按 任何顺序 返回答案。 示例 示例 1: 输入：n = 4, k = 2 输出： [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 示例 2: 输入：n = 1, k = 1 输出：[[1]] 提示： 1 1 解题思路 思路 参考代码思考录 回溯法解决的问题都可以抽象为树形结构（N叉树），用树形结构来理解回溯就容易多了。 那么我把组合问题抽象为如下树形结构： 可以看出这个棵树，一开始集合是 1，2，3，4， 从左向右取数，取过的数，不在重复取。 第一次取1，集合变为2，3，4 ，因为k为2，我们只需要再取一个数就可以了，分别取2，3，4，得到集合[1,2] [1,3] [1,4]，以此类推。 每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围。 图中可以发现n相当于树的宽度，k相当于树的深度。 那么如何在这个树上遍历，然后收集到我们要的结果集呢？ 图中每次搜索到了叶子节点，我们就找到了一个结果。 实现 源码 var ( path = make([]int, 0) // 迭代的路径记录 res = make([][]int, 0) // 最终结果记录 ) func backtracking(n int, k int, startIndex int) { if len(path) == k { // 这里拷贝一定一定要当心!!!!!! temp := make([]int, k) copy(temp, path) res = append(res, temp) return } // for i := startIndex; i Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"backtracking/216-组合总和III.html":{"url":"backtracking/216-组合总和III.html","title":"216. 组合总和III","keywords":"","body":"216. 组合总和 III leecode原题 题目 找出所有相加之和为 n 的 k 个数的组合，且满足下列条件： 只使用数字1到9 每个数字 最多使用一次 返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。 示例 示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]] 解释: 1 + 2 + 4 = 7 没有其他符合的组合了。 示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]] 解释: 1 + 2 + 6 = 9 1 + 3 + 5 = 9 2 + 3 + 4 = 9 没有其他符合的组合了。 示例 3: 输入: k = 4, n = 1 输出: [] 解释: 不存在有效的组合。 在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 > 1，没有有效的组合。 提示： 2 1 解题思路 思路 这道题跟77.组合很像，主要只是多了目标和的限制. 实现 源码 var ( path = make([]int, 0) // 符合条件的结果 res = make([][]int, 0) // 存放最终的结果集 ) func backtracking(k int, targetNum int, startIndex int, sum int) { if sum > targetNum { // 剪枝操作 return } if len(path) == k { if sum == targetNum { tmp := make([]int, k) copy(tmp, path) res = append(res, tmp) } return } for i := startIndex; i Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"backtracking/17-电话号码的字母组合.html":{"url":"backtracking/17-电话号码的字母组合.html","title":"17. 电话号码的字母组合","keywords":"","body":"17. 电话号码的字母组合 leecode原题 题目 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例 示例 1: 输入：digits = \"23\" 输出：[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"] 示例 2: 输入：digits = \"\" 输出：[] 示例 3: 输入：digits = \"2\" 输出：[\"a\",\"b\",\"c\"] 提示： 0 digits[i] 是范围 ['2', '9'] 的一个数字。 解题思路 思路 跟77-组合有所不同，但是也是相应的变种，详细参阅:代码随想录 实现 源码 var ( letterMap = [10]string{ \"\", // 0 \"\", // 1 \"abc\", // 2 \"def\", // 3 \"ghi\", // 4 \"jkl\", // 5 \"mno\", // 6 \"pqrs\", // 7 \"tuv\", // 8 \"wxyz\", // 9 } s = make([]rune, 0) //记录临时结果 res = make([]string, 0) //记录全局结果 ) func backtracking(digits string, index int) { //index代表遍历到digits的第几个字母，也代表深度 if index == len(digits) { res = append(res, string(s)) return } digit := digits[index] - '0' // 将index指向的数字转为int, 比如digits为\"23\", index为0的情况，去代表取出2对应的字符 letters := letterMap[digit] // 取数字对应的字符集 for i := 0; i Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "},"backtracking/39-组合总和.html":{"url":"backtracking/39-组合总和.html","title":"39. 组合总和","keywords":"","body":"39. 组合总和 leecode原题 题目 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。 candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 target 的不同组合数少于 150 个。 示例 示例 1: 输入：candidates = [2,3,6,7], target = 7 输出：[[2,2,3],[7]] 解释： 2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。 7 也是一个候选， 7 = 7 。 仅有这两种组合。 示例 2: 输入: candidates = [2,3,5], target = 8 输出: [[2,2,2,2],[2,3,3],[3,5]] 示例 3: 输入: candidates = [2], target = 1 输出: [] 提示： 1 1 candidate 中的每个元素都 互不相同 1 解题思路 思路 实现 源码 Copyright © ROSEMARY666 2022 all right reserved，powered by Gitbook该文章修订时间： 2022-09-25 15:51:28 "}}